<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>PostGIS Manual</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><meta name="description" content="PostGIS is an extension to the PostgreSQL object-relational database system which allows GIS (Geographic Information Systems) objects to be stored in the database. PostGIS includes support for GiST-based R-Tree spatial indexes, and functions for analysis and processing of GIS objects. This is the manual for version 1.3.3"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id258724"></a>PostGIS Manual</h1></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>PostGIS is an extension to the PostgreSQL object-relational
      database system which allows GIS (Geographic Information Systems)
      objects to be stored in the database. PostGIS includes support for
      GiST-based R-Tree spatial indexes, and functions for analysis and
      processing of GIS objects.</p><p>This is the manual for version 1.3.3</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#id258379">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#credits">1.1. Credits</a></span></dt><dt><span class="sect1"><a href="#id258414">1.2. More Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id258941">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id258947">2.1. Requirements</a></span></dt><dt><span class="sect1"><a href="#PGInstall">2.2. PostGIS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#templatepostgis">2.2.1. Creating PostGIS spatially-enabled databases from an in-built
        template</a></span></dt><dt><span class="sect2"><a href="#upgrading">2.2.2. Upgrading</a></span></dt><dt><span class="sect2"><a href="#id260279">2.2.3. Common Problems</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id260394">2.3. JDBC</a></span></dt><dt><span class="sect1"><a href="#id302826">2.4. Loader/Dumper</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id302859">3. Frequently Asked Questions</a></span></dt><dt><span class="chapter"><a href="#id303237">4. Using PostGIS</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RefObject">4.1. GIS Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id303262">4.1.1. OpenGIS WKB and WKT</a></span></dt><dt><span class="sect2"><a href="#id303354">4.1.2. PostGIS EWKB, EWKT and Canonical Forms</a></span></dt><dt><span class="sect2"><a href="#id303489">4.1.3. SQL-MM Part 3</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id303562">4.2. Using OpenGIS Standards</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id303592">4.2.1. The SPATIAL_REF_SYS Table</a></span></dt><dt><span class="sect2"><a href="#id303761">4.2.2. The GEOMETRY_COLUMNS Table</a></span></dt><dt><span class="sect2"><a href="#id303881">4.2.3. Creating a Spatial Table</a></span></dt><dt><span class="sect2"><a href="#id303971">4.2.4. Ensuring OpenGIS compliancy of geometries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304043">4.3. Loading GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304054">4.3.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="#id304099">4.3.2. Using the Loader</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304306">4.4. Retrieving GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304317">4.4.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="#id304446">4.4.2. Using the Dumper</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304605">4.5. Building Indexes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304654">4.5.1. GiST Indexes</a></span></dt><dt><span class="sect2"><a href="#id304709">4.5.2. Using Indexes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304803">4.6. Complex Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304818">4.6.1. Taking Advantage of Indexes</a></span></dt><dt><span class="sect2"><a href="#id304890">4.6.2. Examples of Spatial SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305122">4.7. Using Mapserver</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305159">4.7.1. Basic Usage</a></span></dt><dt><span class="sect2"><a href="#id305366">4.7.2. Frequently Asked Questions</a></span></dt><dt><span class="sect2"><a href="#id305515">4.7.3. Advanced Usage</a></span></dt><dt><span class="sect2"><a href="#id305647">4.7.4. Examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305728">4.8. Java Clients (JDBC)</a></span></dt><dt><span class="sect1"><a href="#id305784">4.9. C Clients (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305793">4.9.1. Text Cursors</a></span></dt><dt><span class="sect2"><a href="#id305802">4.9.2. Binary Cursors</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id305814">5. Performance tips</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id305819">5.1. Small tables of large geometries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305825">5.1.1. Problem description</a></span></dt><dt><span class="sect2"><a href="#id305872">5.1.2. Workarounds</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305929">5.2. CLUSTERing on geometry indices</a></span></dt><dt><span class="sect1"><a href="#id305981">5.3. Avoiding dimension conversion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id306019">6. PostGIS Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id306040">6.1. OpenGIS Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id306045">6.1.1. Management Functions</a></span></dt><dt><span class="sect2"><a href="#id306118">6.1.2. Geometry Relationship Functions</a></span></dt><dt><span class="sect2"><a href="#id306540">6.1.3. Geometry Processing Functions</a></span></dt><dt><span class="sect2"><a href="#id306824">6.1.4. Geometry Accessors</a></span></dt><dt><span class="sect2"><a href="#id307284">6.1.5. Geometry Constructors</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id307799">6.2. PostGIS Extensions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id307804">6.2.1. Management Functions</a></span></dt><dt><span class="sect2"><a href="#id308090">6.2.2. Operators</a></span></dt><dt><span class="sect2"><a href="#id308280">6.2.3. Measurement Functions</a></span></dt><dt><span class="sect2"><a href="#id308525">6.2.4. Geometry Outputs</a></span></dt><dt><span class="sect2"><a href="#id308642">6.2.5. Geometry Constructors</a></span></dt><dt><span class="sect2"><a href="#id258133">6.2.6. Geometry Editors</a></span></dt><dt><span class="sect2"><a href="#id309528">6.2.7. Linear Referencing</a></span></dt><dt><span class="sect2"><a href="#id309708">6.2.8. Misc</a></span></dt><dt><span class="sect2"><a href="#id310341">6.2.9. Long Transactions support</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id310131">6.3. SQL-MM Functions</a></span></dt><dt><span class="sect1"><a href="#id311488">6.4. ArcSDE Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id311596">7. Reporting Bugs</a></span></dt><dt><span class="appendix"><a href="#release_notes">A. Appendix</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id311650">A.1. Release Notes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id311656">A.1.1. Release 1.3.3</a></span></dt><dt><span class="sect2"><a href="#id311671">A.1.2. Release 1.3.2</a></span></dt><dt><span class="sect2"><a href="#id311685">A.1.3. Release 1.3.1</a></span></dt><dt><span class="sect2"><a href="#id311699">A.1.4. Release 1.3.0</a></span></dt><dt><span class="sect2"><a href="#id311765">A.1.5. Release 1.2.1</a></span></dt><dt><span class="sect2"><a href="#id311804">A.1.6. Release 1.2.0</a></span></dt><dt><span class="sect2"><a href="#id311833">A.1.7. Release 1.1.6</a></span></dt><dt><span class="sect2"><a href="#id311928">A.1.8. Release 1.1.5</a></span></dt><dt><span class="sect2"><a href="#id312022">A.1.9. Release 1.1.4</a></span></dt><dt><span class="sect2"><a href="#id312122">A.1.10. Release 1.1.3</a></span></dt><dt><span class="sect2"><a href="#id312260">A.1.11. Release 1.1.2</a></span></dt><dt><span class="sect2"><a href="#id312371">A.1.12. Release 1.1.1</a></span></dt><dt><span class="sect2"><a href="#id312477">A.1.13. Release 1.1.0</a></span></dt><dt><span class="sect2"><a href="#id312747">A.1.14. Release 1.0.6</a></span></dt><dt><span class="sect2"><a href="#id312836">A.1.15. Release 1.0.5</a></span></dt><dt><span class="sect2"><a href="#id312950">A.1.16. Release 1.0.4</a></span></dt><dt><span class="sect2"><a href="#rel_1.0.3_upgrading">A.1.17. Release 1.0.3</a></span></dt><dt><span class="sect2"><a href="#id313152">A.1.18. Release 1.0.2</a></span></dt><dt><span class="sect2"><a href="#id313220">A.1.19. Release 1.0.1</a></span></dt><dt><span class="sect2"><a href="#id313306">A.1.20. Release 1.0.0</a></span></dt><dt><span class="sect2"><a href="#id313391">A.1.21. Release 1.0.0RC6</a></span></dt><dt><span class="sect2"><a href="#id313456">A.1.22. Release 1.0.0RC5</a></span></dt><dt><span class="sect2"><a href="#id313518">A.1.23. Release 1.0.0RC4</a></span></dt><dt><span class="sect2"><a href="#id313625">A.1.24. Release 1.0.0RC3</a></span></dt><dt><span class="sect2"><a href="#id313774">A.1.25. Release 1.0.0RC2</a></span></dt><dt><span class="sect2"><a href="#id313859">A.1.26. Release 1.0.0RC1</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id258379"></a>Chapter 1. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#credits">1.1. Credits</a></span></dt><dt><span class="sect1"><a href="#id258414">1.2. More Information</a></span></dt></dl></div><p>PostGIS is developed by Refractions Research Inc, as a spatial
    database technology research project. Refractions is a GIS and database
    consulting company in Victoria, British Columbia, Canada, specializing in
    data integration and custom software development. We plan on supporting
    and developing PostGIS to support a range of important GIS functionality,
    including full OpenGIS support, advanced topological constructs
    (coverages, surfaces, networks), desktop user interface tools for viewing
    and editing GIS data, and web-based access tools.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="credits"></a>1.1. Credits</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Sandro Santilli &lt;strk@refractions.net&gt;</span></dt><dd><p>Coordinates all bug fixing and maintenance effort,
            integration of new GEOS functionality, and new function
            enhancements.</p></dd><dt><span class="term">Mark Leslie &lt;mleslie@refractions.net&gt;</span></dt><dd><p>Ongoing maintenance and development of core functions.</p></dd><dt><span class="term">Chris Hodgson &lt;chodgson@refractions.net&gt;</span></dt><dd><p>Maintains new functions and the 7.2 index bindings.</p></dd><dt><span class="term">Paul Ramsey &lt;pramsey@refractions.net&gt;</span></dt><dd><p>Keeps track of the documentation and packaging.</p></dd><dt><span class="term">Jeff Lounsbury &lt;jeffloun@refractions.net&gt;</span></dt><dd><p>Original development of the Shape file loader/dumper.</p></dd><dt><span class="term">Dave Blasby &lt;dblasby@gmail.com&gt;</span></dt><dd><p>The original developer of PostGIS. Dave wrote the server
            side objects, index bindings, and many of the server side
            analytical functions.</p></dd><dt><span class="term">Other contributors</span></dt><dd><p>In alphabetical order: Alex Bodnaru, Alex Mayrhofer, Bruce
            Rindahl, Bernhard Reiter, Bruno Wolff III, Carl Anderson, Charlie
            Savage, David Skea, David Techer, IIDA Tetsushi, Geographic Data
            BC, Gerald Fenoy, Gino Lucrezi, Klaus Foerster, Kris Jurka, Mark
            Cave-Ayland, Mark Sondheim, Markus Schaber, Michael Fuhr, Nikita
            Shulga, Norman Vine, Olivier Courtin, Ralph Mason, Steffen Macke.</p></dd><dt><span class="term">Important Support Libraries</span></dt><dd><p>The <a class="ulink" href="http://geos.refractions.net" target="_top">GEOS</a>
            geometry operations library, and the algorithmic work of Martin
            Davis &lt;mbdavis@vividsolutions.com&gt; of Vivid Solutions in
            making it all work.</p><p>The <a class="ulink" href="http://proj4.maptools.org" target="_top">Proj4</a>
            cartographic projection library, and the work of Gerald Evenden
            and Frank Warmerdam in creating and maintaining it.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id258414"></a>1.2. More Information</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>The latest software, documentation and news items are
          available at the PostGIS web site, <a class="ulink" href="http://postgis.refractions.net" target="_top">http://postgis.refractions.net</a>.</p></li><li><p>More information about the GEOS geometry operations library is
          available at<a class="ulink" href="http://geos.refractions.net" target="_top">
          http://geos.refractions.net</a>.</p></li><li><p>More information about the Proj4 reprojection library is
          available at <a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>.</p></li><li><p>More information about the PostgreSQL database server is
          available at the PostgreSQL main site <a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>.</p></li><li><p>More information about GiST indexing is available at the
          PostgreSQL GiST development site, <a class="ulink" href="http://www.sai.msu.su/~megera/postgres/gist" target="_top">http://www.sai.msu.su/~megera/postgres/gist</a>.</p></li><li><p>More information about Mapserver internet map server is
          available at <a class="ulink" href="http://mapserver.gis.umn.edu/" target="_top">http://mapserver.gis.umn.edu</a>.</p></li><li><p>The "<a class="ulink" href="http://www.opengis.org/docs/99-049.pdf" target="_top">Simple
          Features for Specification for SQL</a>" is available at the
          OpenGIS Consortium web site: <a class="ulink" href="http://www.opengis.org" target="_top">http://www.opengis.org</a>.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id258941"></a>Chapter 2. Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id258947">2.1. Requirements</a></span></dt><dt><span class="sect1"><a href="#PGInstall">2.2. PostGIS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#templatepostgis">2.2.1. Creating PostGIS spatially-enabled databases from an in-built
        template</a></span></dt><dt><span class="sect2"><a href="#upgrading">2.2.2. Upgrading</a></span></dt><dt><span class="sect2"><a href="#id260279">2.2.3. Common Problems</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id260394">2.3. JDBC</a></span></dt><dt><span class="sect1"><a href="#id302826">2.4. Loader/Dumper</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id258947"></a>2.1. Requirements</h2></div></div></div><p>PostGIS has the following requirements for building and usage:</p><div class="itemizedlist"><ul type="disc"><li><p>A complete installation of PostgreSQL (including server
          headers). PostgreSQL is available from <a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>.
          Version 7.2 or higher is required.</p></li><li><p>GNU C compiler (<code class="filename">gcc</code>). Some other ANSI C
          compilers can be used to compile PostGIS, but we find far fewer
          problems when compiling with <code class="filename">gcc</code>.</p></li><li><p>GNU Make (<code class="filename">gmake</code> or <code class="filename">make</code>).
          For many systems, GNU <code class="filename">make</code> is the default
          version of make. Check the version by invoking <code class="filename">make -v</code>.
          Other versions of <code class="filename">make</code> may not process the
          PostGIS <code class="filename">Makefile</code> properly.</p></li><li><p>(Recommended) Proj4 reprojection library. The Proj4 library is
          used to provide coordinate reprojection support within PostGIS.
          Proj4 is available for download from <a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>.</p></li><li><p>(Recommended) GEOS geometry library. The GEOS library is used
          to provide geometry tests (ST_Touches(), ST_Contains(), ST_Intersects()) and
          operations (ST_Buffer(), ST_Union(), ST_Difference()) within PostGIS.
          GEOS is available for download from <a class="ulink" href="http://geos.refractions.net" target="_top">http://geos.refractions.net</a>.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PGInstall"></a>2.2. PostGIS</h2></div></div></div><p>The PostGIS module is a extension to the PostgreSQL backend
      server. As such, PostGIS 1.3.3 <span class="emphasis"><em>requires</em></span>
      full PostgreSQL server headers access in order to compile. The
      PostgreSQL source code is available at <a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>.</p><p>PostGIS 1.3.3 can be built against PostgreSQL
      versions 7.2.0 or higher. Earlier versions of PostgreSQL are
      <span class="emphasis"><em>not</em></span> supported.</p><div class="orderedlist"><ol type="1"><li><p>Before you can compile the PostGIS server modules, you must
          compile and install the PostgreSQL package.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you plan to use GEOS functionality you might need to
            explicitly link PostgreSQL against the standard C++ library:</p><pre class="programlisting">LDFLAGS=-lstdc++ ./configure [YOUR OPTIONS HERE]</pre><p>This is a workaround for bogus C++ exceptions interaction
            with older development tools. If you experience weird problems
            (backend unexpectedly closed or similar things) try this trick.
            This will require recompiling your PostgreSQL from scratch, of
            course.</p></div></li><li><p>Retrieve the PostGIS source archive from <a class="ulink" href="http://postgis.refractions.net/postgis-1.3.3.tar.gz" target="_top">http://postgis.refractions.net/postgis-1.3.3.tar.gz</a>.
          Uncompress and untar the archive.</p><pre class="programlisting"># gzip -d -c postgis-1.3.3.tar.gz | tar xvf -</pre></li><li><p>Enter the postgis-1.3.3 directory, and run:
          </p><pre class="programlisting"># ./configure</pre><div class="itemizedlist"><ul type="disc"><li><p>If you want support for coordinate reprojection, you must
              have the Proj4 library installed. If ./configure didn't find
              it, try using <code class="code">--with-proj=PATH</code> switch specify a
              specific Proj4 installation directory.</p></li><li><p>If you want to use GEOS functionality, you must have the
              GEOS library installed. If ./configure didn't find it, try
              using <code class="code">--with-geos=PATH</code> to specify the full path to
              the geos-config program full path.</p></li></ul></div></li><li><p>Run the compile and install commands.</p><pre class="programlisting"># make # make install</pre><p>All files are installed using information provided by
          <code class="filename">pg_config</code></p><div class="itemizedlist"><ul type="disc"><li><p>Libraries are installed <code class="filename">[pkglibdir]/lib/contrib</code>.</p></li><li><p>Important support files such as <code class="filename">lwpostgis.sql</code>
              are installed in <code class="filename">[prefix]/share/contrib</code>.</p></li><li><p>Loader and dumper binaries are installed in
              <code class="filename">[bindir]/</code>.</p></li></ul></div></li><li><p>PostGIS requires the PL/pgSQL procedural language extension.
          Before loading the <code class="filename">lwpostgis.sql</code> file, you must
          first enable PL/pgSQL. You should use the <code class="filename">createlang</code>
          command. The PostgreSQL Programmer's Guide has the details if
          you want to this manually for some reason.</p><pre class="programlisting"># createlang plpgsql [yourdatabase]</pre></li><li><p>Now load the PostGIS object and function definitions into your
          database by loading the <code class="filename">lwpostgis.sql</code>
          definitions file.</p><pre class="programlisting"># psql -d [yourdatabase] -f lwpostgis.sql</pre><p>The PostGIS server extensions are now loaded and ready to use.</p></li><li><p>For a complete set of EPSG coordinate system definition
          identifiers, you can also load the <code class="filename">spatial_ref_sys.sql</code>
          definitions file and populate the <code class="varname">SPATIAL_REF_SYS</code>
          table.</p><pre class="programlisting"># psql -d [yourdatabase] -f spatial_ref_sys.sql</pre></li></ol></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="templatepostgis"></a>2.2.1. Creating PostGIS spatially-enabled databases from an in-built
        template</h3></div></div></div><p>Some packaged distributions of PostGIS (in particular the Win32
        installers for PostGIS &gt;= 1.1.5) load the PostGIS functions into a
        template database called <code class="varname">template_postgis</code>. If the
        <code class="varname">template_postgis</code> database exists in your PostgreSQL
        installation then it is possible for users and/or applications to
        create spatially-enabled databases using a single command. Note that
        in both cases, the database user must have been granted the privilege
        to create new databases.</p><p>From the shell:</p><pre class="programlisting"># createdb -T template_postgis my_spatial_db</pre><p>From SQL:</p><pre class="programlisting">postgres=# CREATE DATABASE my_spatial_db TEMPLATE=template_postgis</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="upgrading"></a>2.2.2. Upgrading</h3></div></div></div><p>Upgrading existing spatial databases can be tricky as it
        requires replacement or introduction of new PostGIS object
        definitions.</p><p>Unfortunately not all definitions can be easily replaced in a
        live database, so sometimes your best bet is a dump/reload process.</p><p>PostGIS provides a SOFT UPGRADE procedure for minor or bugfix
        releases, and an HARD UPGRADE procedure for major releases.</p><p>Before attempting to upgrade postgis, it is always worth to
        backup your data. If you use the -Fc flag to pg_dump you will always
        be able to restore the dump with an HARD UPGRADE.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="soft_upgrade"></a>2.2.2.1. Soft upgrade</h4></div></div></div><p>Soft upgrade consists of sourcing the lwpostgis_upgrade.sql
          script in your spatial database:</p><pre class="programlisting">$ psql -f lwpostgis_upgrade.sql -d your_spatial_database</pre><p>If a soft upgrade is not possible the script will abort and
          you will be warned about HARD UPGRADE being required, so do not
          hesitate to try a soft upgrade first.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you can't find the <code class="filename">lwpostgis_upgrade.sql</code>
            file you are probably using a version prior to 1.1 and must
            generate that file by yourself. This is done with the following
            command:</p><pre class="programlisting">$ utils/postgis_proc_upgrade.pl lwpostgis.sql &gt; lwpostgis_upgrade.sql</pre></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="hard_upgrade"></a>2.2.2.2. Hard upgrade</h4></div></div></div><p>By HARD UPGRADE we intend full dump/reload of postgis-enabled
          databases. You need an HARD UPGRADE when postgis objects'
          internal storage changes or when SOFT UPGRADE is not possible. The
          <a class="link" href="#release_notes" title="Appendix A. Appendix">Release Notes</a> appendix reports
          for each version whether you need a dump/reload (HARD UPGRADE) to
          upgrade.</p><p>PostGIS provides an utility script to restore a dump produced
          with the pg_dump -Fc command. It is experimental so redirecting its
          output to a file will help in case of problems. The procedure is as
          follow:</p><p>Create a "custom-format" dump of the database you want
          to upgrade (let's call it "olddb")</p><pre class="programlisting">$ pg_dump -Fc olddb &gt; olddb.dump</pre><p>Restore the dump contextually upgrading postgis into a new
          database. The new database doesn't have to exist.
          postgis_restore accepts createdb parameters after the dump file
          name, and that can for instance be used if you are using a
          non-default character encoding for your database. Let's call it
          "newdb", with UNICODE as the character encoding:</p><pre class="programlisting">$ sh utils/postgis_restore.pl lwpostgis.sql newdb olddb.dump -E=UNICODE &gt; restore.log</pre><p>Check that all restored dump objects really had to be restored
          from dump and do not conflict with the ones defined in lwpostgis.sql</p><pre class="programlisting">$ grep ^KEEPING restore.log | less</pre><p>If upgrading from PostgreSQL &lt; 8.0 to &gt;= 8.0 you might
          want to drop the attrelid, varattnum and stats columns in the
          geometry_columns table, which are no-more needed. Keeping them
          won't hurt. DROPPING THEM WHEN REALLY NEEDED WILL DO HURT !</p><pre class="programlisting">$ psql newdb -c "ALTER TABLE geometry_columns DROP attrelid" 
$ psql newdb -c "ALTER TABLE geometry_columns DROP varattnum" 
$ psql newdb -c "ALTER TABLE geometry_columns DROP stats"</pre><p>spatial_ref_sys table is restore from the dump, to ensure your
          custom additions are kept, but the distributed one might contain
          modification so you should backup your entries, drop the table and
          source the new one. If you did make additions we assume you know how
          to backup them before upgrading the table. Replace of it with the
          new one is done like this:</p><pre class="programlisting">$ psql newdb 
newdb=&gt; drop spatial_ref_sys; 
DROP 
newdb=&gt; \i spatial_ref_sys.sql</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id260279"></a>2.2.3. Common Problems</h3></div></div></div><p>There are several things to check when your installation or
        upgrade doesn't go as you expected.</p><div class="orderedlist"><ol type="1"><li><p>It is easiest if you untar the PostGIS distribution into the
            contrib directory under the PostgreSQL source tree. However, if
            this is not possible for some reason, you can set the
            <code class="varname">PGSQL_SRC</code> environment variable to the path to
            the PostgreSQL source directory. This will allow you to compile
            PostGIS, but the <span class="command"><strong>make install</strong></span> may not work, so
            be prepared to copy the PostGIS library and executable files to
            the appropriate locations yourself.</p></li><li><p>Check that you you have installed PostgreSQL 7.2 or newer,
            and that you are compiling against the same version of the
            PostgreSQL source as the version of PostgreSQL that is running.
            Mix-ups can occur when your (Linux) distribution has already
            installed PostgreSQL, or you have otherwise installed PostgreSQL
            before and forgotten about it. PostGIS will only work with
            PostgreSQL 7.2 or newer, and strange, unexpected error messages
            will result if you use an older version. To check the version of
            PostgreSQL which is running, connect to the database using psql
            and run this query:</p><pre class="programlisting">SELECT version();</pre><p>If you are running an RPM based distribution, you can check
            for the existence of pre-installed packages using the
            <span class="command"><strong>rpm</strong></span> command as follows: <span class="command"><strong>rpm -qa | grep
            postgresql</strong></span></p></li></ol></div><p>Also check that you have made any necessary changes to the top
        of the Makefile.config. This includes:</p><div class="orderedlist"><ol type="1"><li><p>If you want to be able to do coordinate reprojections, you
            must install the Proj4 library on your system, set the
            <code class="varname">USE_PROJ</code> variable to 1 and the
            <code class="varname">PROJ_DIR</code> to your installation prefix in the
            Makefile.config.</p></li><li><p>If you want to be able to use GEOS functions you must
            install the GEOS library on your system, and set the
            <code class="varname">USE_GEOS</code> to 1 and the <code class="varname">GEOS_DIR</code>
            to your installation prefix in the Makefile.config</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id260394"></a>2.3. JDBC</h2></div></div></div><p>The JDBC extensions provide Java objects corresponding to the
      internal PostGIS types. These objects can be used to write Java clients
      which query the PostGIS database and draw or do calculations on the GIS
      data in PostGIS.</p><div class="orderedlist"><ol type="1"><li><p>Enter the <code class="filename">jdbc</code> sub-directory of the
          PostGIS distribution.</p></li><li><p>Edit the <code class="filename">Makefile</code> to provide the correct
          paths of your java compiler (<code class="varname">JAVAC</code>) and
          interpreter (<code class="varname">JAVA</code>).</p></li><li><p>Run the <code class="filename">make</code> command. Copy the
          <code class="filename">postgis.jar</code> file to wherever you keep your java
          libraries.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id302826"></a>2.4. Loader/Dumper</h2></div></div></div><p>The data loader and dumper are built and installed automatically
      as part of the PostGIS build. To build and install them manually:</p><pre class="programlisting"># cd postgis-1.3.3/loader 
# make 
# make install</pre><p>The loader is called <code class="filename">shp2pgsql</code> and converts
      ESRI Shape files into SQL suitable for loading in PostGIS/PostgreSQL.
      The dumper is called <code class="filename">pgsql2shp</code> and converts PostGIS
      tables (or queries) into ESRI Shape files. For more verbose
      documentation, see the online help, and the manual pages.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id302859"></a>Chapter 3. Frequently Asked Questions</h2></div></div></div><div class="qandaset"><dl><dt>3.1. <a href="#id302866">What kind of geometric objects can I store?</a></dt><dt>3.2. <a href="#id302884">How do I insert a GIS object into the database?</a></dt><dt>3.3. <a href="#id302964">How do I construct a spatial query?</a></dt><dt>3.4. <a href="#id303017">How do I speed up spatial queries on large tables?</a></dt><dt>3.5. <a href="#id303087">Why aren't PostgreSQL R-Tree indexes supported?</a></dt><dt>3.6. <a href="#id303134">Why should I use the AddGeometryColumn()
          function and all the other OpenGIS stuff?</a></dt><dt>3.7. <a href="#id303172">What is the best way to find all objects within a radius of
          another object?</a></dt><dt>3.8. <a href="#id303210">How do I perform a coordinate reprojection as part of a query?</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id302866"></a><a name="id302869"></a><p><b>3.1.</b></p></td><td align="left" valign="top"><p>What kind of geometric objects can I store?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>You can store point, line, polygon, multipoint, multiline,
          multipolygon, and geometrycollections. These are specified in the
          Open GIS Well Known Text Format (with XYZ,XYM,XYZM extentions).</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id302884"></a><a name="id302886"></a><p><b>3.2.</b></p></td><td align="left" valign="top"><p>How do I insert a GIS object into the database?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>First, you need to create a table with a column of type
          "geometry" to hold your GIS data. Connect to your database
          with <code class="filename">psql</code> and try the following SQL:</p><pre class="programlisting">CREATE TABLE gtest ( ID int4, NAME varchar(20) );
SELECT AddGeometryColumn('', 'gtest','geom',-1,'LINESTRING',2);</pre><p>If the geometry column addition fails, you probably have not
          loaded the PostGIS functions and objects into this database. See the
          <a class="link" href="#PGInstall" title="2.2. PostGIS">installation instructions</a>.</p><p>Then, you can insert a geometry into the table using a SQL
          insert statement. The GIS object itself is formatted using the
          OpenGIS Consortium "well-known text" format:</p><pre class="programlisting">INSERT INTO gtest (ID, NAME, GEOM) 
VALUES (
  1, 
  'First Geometry', 
  GeomFromText('LINESTRING(2 3,4 5,6 5,7 8)', -1)
);</pre><p>For more information about other GIS objects, see the <a class="link" href="#RefObject" title="4.1. GIS Objects">object reference</a>.</p><p>To view your GIS data in the table:</p><pre class="programlisting">SELECT id, name, AsText(geom) AS geom FROM gtest;</pre><p>The return value should look something like this:</p><pre class="programlisting"> id | name           | geom
----+----------------+-----------------------------
  1 | First Geometry | LINESTRING(2 3,4 5,6 5,7 8) 
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id302964"></a><a name="id302966"></a><p><b>3.3.</b></p></td><td align="left" valign="top"><p>How do I construct a spatial query?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>The same way you construct any other database query, as an SQL
          combination of return values, functions, and boolean tests.</p><p>For spatial queries, there are two issues that are important
          to keep in mind while constructing your query: is there a spatial
          index you can make use of; and, are you doing expensive calculations
          on a large number of geometries.</p><p>In general, you will want to use the "intersects
          operator" (&amp;&amp;) which tests whether the bounding boxes of
          features intersect. The reason the &amp;&amp; operator is useful is
          because if a spatial index is available to speed up the test, the
          &amp;&amp; operator will make use of this. This can make queries
          much much faster.</p><p>You will also make use of spatial functions, such as
          Distance(), ST_Intersects(), ST_Contains() and ST_Within(), 
          among others, to
          narrow down the results of your search. Most spatial queries include
          both an indexed test and a spatial function test. The index test
          serves to limit the number of return tuples to only tuples that
          <span class="emphasis"><em>might</em></span> meet the condition of interest. The
          spatial functions are then use to test the condition exactly.</p><pre class="programlisting">SELECT id, the_geom 
FROM thetable 
WHERE 
  the_geom &amp;&amp; 'POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))' 
AND
  _ST_Contains(the_geom,'POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))');</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id303017"></a><a name="id303019"></a><p><b>3.4.</b></p></td><td align="left" valign="top"><p>How do I speed up spatial queries on large tables?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Fast queries on large tables is the <span class="emphasis"><em>raison
          d'etre</em></span> of spatial databases (along with transaction
          support) so having a good index is important.</p><p>To build a spatial index on a table with a <code class="varname">geometry</code>
          column, use the "CREATE INDEX" function as follows:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometrycolumn] );</pre><p>The "USING GIST" option tells the server to use a GiST
          (Generalized Search Tree) index.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>GiST indexes are assumed to be lossy. Lossy indexes uses a
            proxy object (in the spatial case, a bounding box) for building
            the index.</p></div><p>You should also ensure that the PostgreSQL query planner has
          enough information about your index to make rational decisions about
          when to use it. To do this, you have to "gather statistics"
          on your geometry tables.</p><p>For PostgreSQL 8.0.x and greater, just run the
          <span class="command"><strong>VACUUM ANALYZE</strong></span> command.</p><p>For PostgreSQL 7.4.x and below, run the <span class="command"><strong>SELECT
          UPDATE_GEOMETRY_STATS()</strong></span> command.</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id303087"></a><a name="id303090"></a><p><b>3.5.</b></p></td><td align="left" valign="top"><p>Why aren't PostgreSQL R-Tree indexes supported?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Early versions of PostGIS used the PostgreSQL R-Tree indexes.
          However, PostgreSQL R-Trees have been completely discarded since
          version 0.6, and spatial indexing is provided with an
          R-Tree-over-GiST scheme.</p><p>Our tests have shown search speed for native R-Tree and GiST
          to be comparable. Native PostgreSQL R-Trees have two limitations
          which make them undesirable for use with GIS features (note that
          these limitations are due to the current PostgreSQL native R-Tree
          implementation, not the R-Tree concept in general):</p><div class="itemizedlist"><ul type="disc"><li><p>R-Tree indexes in PostgreSQL cannot handle features which
              are larger than 8K in size. GiST indexes can, using the
              "lossy" trick of substituting the bounding box for the
              feature itself.</p></li><li><p>R-Tree indexes in PostgreSQL are not "null safe",
              so building an index on a geometry column which contains null
              geometries will fail.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a name="id303134"></a><a name="id303136"></a><p><b>3.6.</b></p></td><td align="left" valign="top"><p>Why should I use the <code class="varname">AddGeometryColumn()</code>
          function and all the other OpenGIS stuff?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>If you do not want to use the OpenGIS support functions, you
          do not have to. Simply create tables as in older versions, defining
          your geometry columns in the CREATE statement. All your geometries
          will have SRIDs of -1, and the OpenGIS meta-data tables will
          <span class="emphasis"><em>not</em></span> be filled in properly. However, this will
          cause most applications based on PostGIS to fail, and it is
          generally suggested that you do use <code class="varname">AddGeometryColumn()</code>
          to create geometry tables.</p><p>Mapserver is one application which makes use of the
          <code class="varname">geometry_columns</code> meta-data. Specifically,
          Mapserver can use the SRID of the geometry column to do on-the-fly
          reprojection of features into the correct map projection.</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id303172"></a><a name="id303174"></a><p><b>3.7.</b></p></td><td align="left" valign="top"><p>What is the best way to find all objects within a radius of
          another object?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>To use the database most efficiently, it is best to do radius
          queries which combine the radius test with a bounding box test: the
          bounding box test uses the spatial index, giving fast access to a
          subset of data which the radius test is then applied to.</p><p>The <code class="varname">ST_DWithin(geometry, geometry, distance)</code> 
          function is a handy way of performing an indexed distance search.  
          It works by creating a search rectangle large enough to enclose the
          distance radius, then performing an exact distance search on the 
          indexed subset of results.</p><p>For example, to find all objects with 100 meters of POINT(1000
          1000) the following query would work well:</p><pre class="programlisting">SELECT * FROM geotable 
  WHERE ST_DWithin(geocolumn, 'POINT(1000 1000)', 100.0);</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id303210"></a><a name="id303213"></a><p><b>3.8.</b></p></td><td align="left" valign="top"><p>How do I perform a coordinate reprojection as part of a query?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>To perform a reprojection, both the source and destination
          coordinate systems must be defined in the SPATIAL_REF_SYS table, and
          the geometries being reprojected must already have an SRID set on
          them. Once that is done, a reprojection is as simple as referring to
          the desired destination SRID.</p><pre class="programlisting">SELECT ST_Transform(the_geom,4269) FROM geotable;</pre></td></tr></tbody></table></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id303237"></a>Chapter 4. Using PostGIS</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#RefObject">4.1. GIS Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id303262">4.1.1. OpenGIS WKB and WKT</a></span></dt><dt><span class="sect2"><a href="#id303354">4.1.2. PostGIS EWKB, EWKT and Canonical Forms</a></span></dt><dt><span class="sect2"><a href="#id303489">4.1.3. SQL-MM Part 3</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id303562">4.2. Using OpenGIS Standards</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id303592">4.2.1. The SPATIAL_REF_SYS Table</a></span></dt><dt><span class="sect2"><a href="#id303761">4.2.2. The GEOMETRY_COLUMNS Table</a></span></dt><dt><span class="sect2"><a href="#id303881">4.2.3. Creating a Spatial Table</a></span></dt><dt><span class="sect2"><a href="#id303971">4.2.4. Ensuring OpenGIS compliancy of geometries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304043">4.3. Loading GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304054">4.3.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="#id304099">4.3.2. Using the Loader</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304306">4.4. Retrieving GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304317">4.4.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="#id304446">4.4.2. Using the Dumper</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304605">4.5. Building Indexes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304654">4.5.1. GiST Indexes</a></span></dt><dt><span class="sect2"><a href="#id304709">4.5.2. Using Indexes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id304803">4.6. Complex Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id304818">4.6.1. Taking Advantage of Indexes</a></span></dt><dt><span class="sect2"><a href="#id304890">4.6.2. Examples of Spatial SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305122">4.7. Using Mapserver</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305159">4.7.1. Basic Usage</a></span></dt><dt><span class="sect2"><a href="#id305366">4.7.2. Frequently Asked Questions</a></span></dt><dt><span class="sect2"><a href="#id305515">4.7.3. Advanced Usage</a></span></dt><dt><span class="sect2"><a href="#id305647">4.7.4. Examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305728">4.8. Java Clients (JDBC)</a></span></dt><dt><span class="sect1"><a href="#id305784">4.9. C Clients (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305793">4.9.1. Text Cursors</a></span></dt><dt><span class="sect2"><a href="#id305802">4.9.2. Binary Cursors</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. GIS Objects</h2></div></div></div><p>The GIS objects supported by PostGIS are a superset of the
      "Simple Features" defined by the OpenGIS Consortium (OGC). As of
      version 0.9, PostGIS supports all the objects and functions specified in
      the OGC "Simple Features for SQL" specification.</p><p>PostGIS extends the standard with support for 3DZ,3DM and 4D
      coordinates.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303262"></a>4.1.1. OpenGIS WKB and WKT</h3></div></div></div><p>The OpenGIS specification defines two standard ways of
        expressing spatial objects: the Well-Known Text (WKT) form and the
        Well-Known Binary (WKB) form. Both WKT and WKB include information
        about the type of the object and the coordinates which form the
        object.</p><p>Examples of the text representations (WKT) of the spatial
        objects of the features are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>POINT(0 0)</p></li><li><p>LINESTRING(0 0,1 1,1 2)</p></li><li><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li><p>MULTIPOINT(0 0,1 2)</p></li><li><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)),
            ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING((2 3,3 4)))</p></li></ul></div><p>The OpenGIS specification also requires that the internal
        storage format of spatial objects include a spatial referencing system
        identifier (SRID). The SRID is required when creating spatial objects
        for insertion into the database.</p><p>Input/Output of these formats are available using the following
        interfaces:</p><pre class="programlisting">bytea WKB = asBinary(geometry); 
text WKT = asText(geometry); 
geometry = GeomFromWKB(bytea WKB, SRID); 
geometry = GeometryFromText(text WKT, SRID);</pre><p>For example, a valid insert statement to create and insert an
        OGC spatial object would be:</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303354"></a>4.1.2. PostGIS EWKB, EWKT and Canonical Forms</h3></div></div></div><p>OGC formats only support 2d geometries, and the associated SRID
        is *never* embedded in the input/output representations.</p><p>PostGIS extended formats are currently superset of OGC one
        (every valid WKB/WKT is a valid EWKB/EWKT) but this might vary in the
        future, specifically if OGC comes out with a new format conflicting
        with our extensions. Thus you SHOULD NOT rely on this feature!</p><p>PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and
        embedded SRID information.</p><p>Examples of the text representations (EWKT) of the extended
        spatial objects of the features are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>POINT(0 0 0) -- XYZ</p></li><li><p>SRID=32632;POINT(0 0) -- XY with SRID</p></li><li><p>POINTM(0 0 0) -- XYM</p></li><li><p>POINT(0 0 0 0) -- XYZM</p></li><li><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID</p></li><li><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))</p></li><li><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1
            2 0,1 1 0))</p></li><li><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2
            2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li><p>GEOMETRYCOLLECTIONM(POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4
            5))</p></li></ul></div><p>Input/Output of these formats are available using the following
        interfaces:</p><pre class="programlisting">bytea EWKB = asEWKB(geometry); 
text EWKT = asEWKT(geometry); 
geometry = GeomFromEWKB(bytea EWKB); 
geometry = GeomFromEWKT(text EWKT);</pre><p>For example, a valid insert statement to create and insert a
        PostGIS spatial object would be:</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name ) 
  VALUES ( GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre><p>The "canonical forms" of a PostgreSQL type are the
        representations you get with a simple query (without any function
        call) and the one which is guaranteed to be accepted with a simple
        insert, update or copy. For the postgis 'geometry' type these
        are: </p><pre class="programlisting">- Output 
  - binary: EWKB 
    ascii: HEXEWKB (EWKB in hex form) 
- Input 
  - binary: EWKB 
    ascii: HEXEWKB|EWKT </pre><p>For example this statement reads EWKT and returns HEXEWKB in the
        process of canonical ascii input/output:</p><pre class="programlisting">=# SELECT 'SRID=4;POINT(0 0)'::geometry;

geometry 
----------------------------------------------------
01010000200400000000000000000000000000000000000000 
(1 row)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303489"></a>4.1.3. SQL-MM Part 3</h3></div></div></div><p>The SQL Multimedia Applications Spatial specification extends
        the simple features for SQL spec by defining a number of circularly
        interpolated curves.</p><p>The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but
        do not allow the embedding of SRID information.</p><p>The well-known text extensions are not yet fully supported.
        Examples of some simple curved geometries are shown below:</p><div class="itemizedlist"><ul type="disc"><li><p>CIRCULARSTRING(0 0, 1 1, 1 0)</p></li><li><p>COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</p></li><li><p>CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3
            3, 3 1, 1 1))</p></li><li><p>MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))</p></li><li><p>MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4,
            0 0),(1 1, 3 3, 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11,
            11.5 11, 11 11.5, 11 11)))</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Currently, PostGIS cannot support the use of Compound Curves
          in a Curve Polygon.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>All floating point comparisons within the SQL-MM
          implementation are performed to a specified tolerance, currently
          1E-8.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id303562"></a>4.2. Using OpenGIS Standards</h2></div></div></div><p>The OpenGIS "Simple Features Specification for SQL"
      defines standard GIS object types, the functions required to manipulate
      them, and a set of meta-data tables. In order to ensure that meta-data
      remain consistent, operations such as creating and removing a spatial
      column are carried out through special procedures defined by OpenGIS.</p><p>There are two OpenGIS meta-data tables: <code class="varname">SPATIAL_REF_SYS</code>
      and <code class="varname">GEOMETRY_COLUMNS</code>. The <code class="varname">SPATIAL_REF_SYS</code>
      table holds the numeric IDs and textual descriptions of coordinate
      systems used in the spatial database.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303592"></a>4.2.1. The SPATIAL_REF_SYS Table</h3></div></div></div><p>The <code class="varname">SPATIAL_REF_SYS</code> table definition is as
        follows:</p><pre class="programlisting">CREATE TABLE spatial_ref_sys ( 
  srid       INTEGER NOT NULL PRIMARY KEY, 
  auth_name  VARCHAR(256), 
  auth_srid  INTEGER, 
  srtext     VARCHAR(2048), 
  proj4text  VARCHAR(2048) 
)</pre><p>The <code class="varname">SPATIAL_REF_SYS</code> columns are as follows:</p><div class="variablelist"><dl><dt><span class="term">SRID</span></dt><dd><p>An integer value that uniquely identifies the Spatial
              Referencing System (SRS) within the database.</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>The name of the standard or standards body that is being
              cited for this reference system. For example, "EPSG"
              would be a valid <code class="varname">AUTH_NAME</code>.</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p>The ID of the Spatial Reference System as defined by the
              Authority cited in the <code class="varname">AUTH_NAME</code>. In the case
              of EPSG, this is where the EPSG projection code would go.</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>The Well-Known Text representation of the Spatial
              Reference System. An example of a WKT SRS representation is:</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
    DATUM["North_American_Datum_1983", 
      SPHEROID["GRS 1980",6378137,298.257222101] 
    ],
    PRIMEM["Greenwich",0],
    UNIT["degree",0.0174532925199433] 
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0], 
  UNIT["metre",1] 
]</pre><p>For a listing of EPSG projection codes and their
              corresponding WKT representations, see <a class="ulink" href="http://www.opengis.org/techno/interop/EPSG2WKT.TXT" target="_top">http://www.opengis.org/techno/interop/EPSG2WKT.TXT</a>.
              For a discussion of WKT in general, see the OpenGIS
              "Coordinate Transformation Services Implementation
              Specification" at <a class="ulink" href="http://www.opengis.org/techno/specs.htm" target="_top">http://www.opengis.org/techno/specs.htm</a>.
              For information on the European Petroleum Survey Group (EPSG)
              and their database of spatial reference systems, see <a class="ulink" href="http://epsg.org" target="_top">http://epsg.org</a>.</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGIS uses the Proj4 library to provide coordinate
              transformation capabilities. The <code class="varname">PROJ4TEXT</code>
              column contains the Proj4 coordinate definition string for a
              particular SRID. For example:</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>For more information about, see the Proj4 web site at
              <a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>.
              The <code class="filename">spatial_ref_sys.sql</code> file contains both
              <code class="varname">SRTEXT</code> and <code class="varname">PROJ4TEXT</code>
              definitions for all EPSG projections.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303761"></a>4.2.2. The GEOMETRY_COLUMNS Table</h3></div></div></div><p>The <code class="varname">GEOMETRY_COLUMNS</code> table definition is as
        follows:</p><pre class="programlisting">CREATE TABLE geometry_columns ( 
  f_table_catalog    VARRCHAR(256) NOT NULL, 
  f_table_schema     VARCHAR(256) NOT NULL,
  f_table_nam        VARCHAR(256) NOT NULL, 
  f_geometry_column  VARCHAR(256) NOT NULL, 
  coord_dimension    INTEGER NOT NULL, 
  srid               INTEGER NOT NULL, 
  type               VARCHAR(30) NOT NULL 
)</pre><p>The columns are as follows:</p><div class="variablelist"><dl><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>The fully qualified name of the feature table containing
              the geometry column. Note that the terms "catalog" and
              "schema" are Oracle-ish. There is not PostgreSQL
              analogue of "catalog" so that column is left blank --
              for "schema" the PostgreSQL schema name is used (<code class="varname">public</code>
              is the default).</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>The name of the geometry column in the feature table.</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>The spatial dimension (2, 3 or 4 dimensional) of the
              column.</p></dd><dt><span class="term">SRID</span></dt><dd><p>The ID of the spatial reference system used for the
              coordinate geometry in this table. It is a foreign key reference
              to the <code class="varname">SPATIAL_REF_SYS</code>.</p></dd><dt><span class="term">TYPE</span></dt><dd><p>The type of the spatial object. To restrict the spatial
              column to a single type, use one of: POINT, LINESTRING, POLYGON,
              MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION or
              corresponding XYM versions POINTM, LINESTRINGM, POLYGONM,
              MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM,
              GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections,
              you can use "GEOMETRY" as the type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This attribute is (probably) not part of the OpenGIS
                specification, but is required for ensuring type homogeneity.</p></div></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303881"></a>4.2.3. Creating a Spatial Table</h3></div></div></div><p>Creating a table with spatial data is done in two stages:</p><div class="itemizedlist"><ul type="disc"><li><p>Create a normal non-spatial table.</p><p>For example: <span class="command"><strong>CREATE TABLE ROADS_GEOM ( ID int4,
            NAME varchar(25) )</strong></span></p></li><li><p>Add a spatial column to the table using the OpenGIS
            "AddGeometryColumn" function.</p><p>The syntax is: </p><pre class="programlisting">AddGeometryColumn(
  &lt;schema_name&gt;,
  &lt;table_name&gt;, 
  &lt;column_name&gt;, 
  &lt;srid&gt;,
  &lt;type&gt;, 
  &lt;dimension&gt;
)</pre><p> Or, using
            current schema: </p><pre class="programlisting">AddGeometryColumn(
  &lt;table_name&gt;,
  &lt;column_name&gt;, 
  &lt;srid&gt;, 
  &lt;type&gt;,
  &lt;dimension&gt;
)</pre><p>Example1: <span class="command"><strong>SELECT
            AddGeometryColumn('public', 'roads_geom',
            'geom', 423, 'LINESTRING', 2)</strong></span></p><p>Example2: <span class="command"><strong>SELECT AddGeometryColumn(
            'roads_geom', 'geom', 423, 'LINESTRING',
            2)</strong></span></p></li></ul></div><p>Here is an example of SQL used to create a table and add a
        spatial column (assuming that an SRID of 128 exists already):</p><pre class="programlisting">CREATE TABLE parks ( 
  park_id    INTEGER, 
  park_name  VARCHAR,
  park_date  DATE,
  park_type  VARCHAR
);
SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );</pre><p>Here is another example, using the generic "geometry"
        type and the undefined SRID value of -1:</p><pre class="programlisting">CREATE TABLE roads ( 
  road_id INTEGER,
  road_name VARCHAR
);
SELECT AddGeometryColumn( 'roads', 'roads_geom', -1, 'GEOMETRY', 3 );</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id303971"></a>4.2.4. Ensuring OpenGIS compliancy of geometries</h3></div></div></div><p>Most of the functions implemented by the GEOS library rely on
        the assumption that your geometries are valid as specified by the
        OpenGIS Simple Feature Specification. To check validity of geometries
        you can use the <a class="link" href="#IsValid">IsValid()</a> function:</p><pre class="programlisting"> gisdb=# select isvalid('LINESTRING(0 0, 1 1)'), 
        isvalid('LINESTRING(0 0,0 0)'); 

 isvalid | isvalid
---------+--------- 
       t |       f</pre><p>By default, PostGIS does not apply this validity check on
        geometry input, because testing for validity needs lots of CPU time
        for complex geometries, especially polygons. If you do not trust your
        data sources, you can manually enforce such a check to your tables by
        adding a check constraint:</p><pre class="programlisting">ALTER TABLE mytable 
  ADD CONSTRAINT geometry_valid_check 
    CHECK (isvalid(the_geom));</pre><p>If you encounter any strange error messages such as "GEOS
        Intersection() threw an error!" or "JTS Intersection() threw
        an error!" when calling PostGIS functions with valid input
        geometries, you likely found an error in either PostGIS or one of the
        libraries it uses, and you should contact the PostGIS developers. The
        same is true if a PostGIS function returns an invalid geometry for
        valid input.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Strictly compliant OGC geometries cannot have Z or M values.
          The <a class="link" href="#IsValid">IsValid()</a> function won't
          consider higher dimensioned geometries invalid! Invocations of <a class="link" href="#AddGeometryColumn">AddGeometryColumn()</a> will add a
          constraint checking geometry dimensions, so it is enough to specify
          2 there.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id304043"></a>4.3. Loading GIS Data</h2></div></div></div><p>Once you have created a spatial table, you are ready to upload GIS
      data to the database. Currently, there are two ways to get data into a
      PostGIS/PostgreSQL database: using formatted SQL statements or using the
      Shape file loader/dumper.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304054"></a>4.3.1. Using SQL</h3></div></div></div><p>If you can convert your data to a text representation, then
        using formatted SQL might be the easiest way to get your data into
        PostGIS. As with Oracle and other SQL databases, data can be bulk
        loaded by piping a large text file full of SQL "INSERT"
        statements into the SQL terminal monitor.</p><p>A data upload file (<code class="filename">roads.sql</code> for example)
        might look like this:</p><pre class="programlisting">BEGIN; 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (1,GeomFromText('LINESTRING(191232 243118,191108 243242)',-1),'Jeff Rd'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (2,GeomFromText('LINESTRING(189141 244158,189265 244817)',-1),'Geordie Rd'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (3,GeomFromText('LINESTRING(192783 228138,192612 229814)',-1),'Paul St'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (4,GeomFromText('LINESTRING(189412 252431,189631 259122)',-1),'Graeme Ave'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (5,GeomFromText('LINESTRING(190131 224148,190871 228134)',-1),'Phil Tce'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (6,GeomFromText('LINESTRING(198231 263418,198213 268322)',-1),'Dave Cres'); 
COMMIT;</pre><p>The data file can be piped into PostgreSQL very easily using the
        "psql" SQL terminal monitor:</p><pre class="programlisting">psql -d [database] -f roads.sql</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304099"></a>4.3.2. Using the Loader</h3></div></div></div><p>The <code class="filename">shp2pgsql</code> data loader converts ESRI
        Shape files into SQL suitable for insertion into a PostGIS/PostgreSQL
        database. The loader has several operating modes distinguished by
        command line flags:</p><div class="variablelist"><dl><dt><span class="term">-d</span></dt><dd><p>Drops the database table before creating a new table with
              the data in the Shape file.</p></dd><dt><span class="term">-a</span></dt><dd><p>Appends data from the Shape file into the database table.
              Note that to use this option to load multiple files, the files
              must have the same attributes and same data types.</p></dd><dt><span class="term">-c</span></dt><dd><p>Creates a new table and populates it from the Shape file.
              <span class="emphasis"><em>This is the default mode.</em></span></p></dd><dt><span class="term">-p</span></dt><dd><p>Only produces the table creation SQL code, without adding
              any actual data. This can be used if you need to completely
              separate the table creation and data loading steps.</p></dd><dt><span class="term">-D</span></dt><dd><p>Use the PostgreSQL "dump" format for the output
              data. This can be combined with -a, -c and -d. It is much faster
              to load than the default "insert" SQL format. Use this
              for very large data sets.</p></dd><dt><span class="term">-s &lt;SRID&gt;</span></dt><dd><p>Creates and populates the geometry tables with the
              specified SRID.</p></dd><dt><span class="term">-k</span></dt><dd><p>Keep identifiers' case (column, schema and
              attributes). Note that attributes in Shapefile are all
              UPPERCASE.</p></dd><dt><span class="term">-i</span></dt><dd><p>Coerce all integers to standard 32-bit integers, do not
              create 64-bit bigints, even if the DBF header signature appears
              to warrant it.</p></dd><dt><span class="term">-I</span></dt><dd><p>Create a GiST index on the geometry column.</p></dd><dt><span class="term">-w</span></dt><dd><p>Output WKT format, for use with older (0.x) versions of
              PostGIS. Note that this will introduce coordinate drifts and
              will drop M values from shapefiles.</p></dd><dt><span class="term">-W &lt;encoding&gt;</span></dt><dd><p>Specify encoding of the input data (dbf file). When used,
              all attributes of the dbf are converted from the specified
              encoding to UTF8. The resulting SQL output will contain a
              <code class="code">SET CLIENT_ENCODING to UTF8</code> command, so that the
              backend will be able to reconvert from UTF8 to whatever encoding
              the database is configured to use internally.</p></dd></dl></div><p>Note that -a, -c, -d and -p are mutually exclusive.</p><p>An example session using the loader to create an input file and
        uploading it might look like this:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable &gt; roads.sql 
# psql -d roadsdb -f roads.sql</pre><p>A conversion and upload can be done all in one step using UNIX
        pipes:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id304306"></a>4.4. Retrieving GIS Data</h2></div></div></div><p>Data can be extracted from the database using either SQL or the
      Shape file loader/dumper. In the section on SQL we will discuss some of
      the operators available to do comparisons and queries on spatial tables.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304317"></a>4.4.1. Using SQL</h3></div></div></div><p>The most straightforward means of pulling data out of the
        database is to use a SQL select query and dump the resulting columns
        into a parsable text file:</p><pre class="programlisting">db=# SELECT road_id, AsText(road_geom) AS geom, road_name FROM roads; 

road_id | geom                                    | road_name
--------+-----------------------------------------+----------- 
      1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd 
      2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd 
      3 | LINESTRING(192783 228138,192612 229814) | Paul St 
      4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
      5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
      6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
      7 | LINESTRING(218421 284121,224123 241231) | Chris Way 
(6 rows)</pre><p>However, there will be times when some kind of restriction is
        necessary to cut down the number of fields returned. In the case of
        attribute-based restrictions, just use the same SQL syntax as normal
        with a non-spatial table. In the case of spatial restrictions, the
        following operators are available/useful:</p><div class="variablelist"><dl><dt><span class="term">&amp;&amp;</span></dt><dd><p>This operator tells whether the bounding box of one
              geometry intersects the bounding box of another.</p></dd><dt><span class="term">~=</span></dt><dd><p>This operators tests whether two geometries are
              geometrically identical. For example, if 'POLYGON((0 0,1 1,1
              0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 0))'
              (it is).</p></dd><dt><span class="term">=</span></dt><dd><p>This operator is a little more naive, it only tests
              whether the bounding boxes of to geometries are the same.</p></dd></dl></div><p>Next, you can use these operators in queries. Note that when
        specifying geometries and boxes on the SQL command line, you must
        explicitly turn the string representations into geometries by using
        the "GeomFromText()" function. So, for example:</p><pre class="programlisting">SELECT road_id, road_name 
  FROM roads 
  WHERE roads_geom ~= GeomFromText('LINESTRING(191232 243118,191108 243242)',-1);</pre><p>The above query would return the single record from the
        "ROADS_GEOM" table in which the geometry was equal to that
        value.</p><p>When using the "&amp;&amp;" operator, you can specify
        either a BOX3D as the comparison feature or a GEOMETRY. When you
        specify a GEOMETRY, however, its bounding box will be used for the
        comparison.</p><pre class="programlisting">SELECT road_id, road_name 
FROM roads 
WHERE roads_geom &amp;&amp; GeomFromText('POLYGON((...))',-1);</pre><p>The above query will use the bounding box of the polygon for
        comparison purposes.</p><p>The most common spatial query will probably be a
        "frame-based" query, used by client software, like data
        browsers and web mappers, to grab a "map frame" worth of data
        for display. Using a "BOX3D" object for the frame, such a
        query looks like this:</p><pre class="programlisting">SELECT AsText(roads_geom) AS geom 
FROM roads 
WHERE 
  roads_geom &amp;&amp; SetSRID('BOX3D(191232 243117,191232 243119)'::box3d,-1);</pre><p>Note the use of the SRID, to specify the projection of the
        BOX3D. The value -1 is used to indicate no specified SRID.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304446"></a>4.4.2. Using the Dumper</h3></div></div></div><p>The <code class="filename">pgsql2shp</code> table dumper connects
        directly to the database and converts a table (possibly defined by a
        query) into a shape file. The basic syntax is:</p><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;</pre><p>The commandline options are:</p><div class="variablelist"><dl><dt><span class="term">-f &lt;filename&gt;</span></dt><dd><p>Write the output to a particular filename.</p></dd><dt><span class="term">-h &lt;host&gt;</span></dt><dd><p>The database host to connect to.</p></dd><dt><span class="term">-p &lt;port&gt;</span></dt><dd><p>The port to connect to on the database host.</p></dd><dt><span class="term">-P &lt;password&gt;</span></dt><dd><p>The password to use when connecting to the database.</p></dd><dt><span class="term">-u &lt;user&gt;</span></dt><dd><p>The username to use when connecting to the database.</p></dd><dt><span class="term">-g &lt;geometry column&gt;</span></dt><dd><p>In the case of tables with multiple geometry columns, the
              geometry column to use when writing the shape file.</p></dd><dt><span class="term">-b</span></dt><dd><p>Use a binary cursor. This will make the operation faster,
              but will not work if any NON-geometry attribute in the table
              lacks a cast to text.</p></dd><dt><span class="term">-r</span></dt><dd><p>Raw mode. Do not drop the <code class="varname">gid</code> field, or
              escape column names.</p></dd><dt><span class="term">-d</span></dt><dd><p>For backward compatibility: write a 3-dimensional shape
              file when dumping from old (pre-1.0.0) postgis databases (the
              default is to write a 2-dimensional shape file in that case).
              Starting from postgis-1.0.0+, dimensions are fully encoded.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id304605"></a>4.5. Building Indexes</h2></div></div></div><p>Indexes are what make using a spatial database for large data sets
      possible. Without indexing, any search for a feature would require a
      "sequential scan" of every record in the database. Indexing
      speeds up searching by organizing the data into a search tree which can
      be quickly traversed to find a particular record. PostgreSQL supports
      three kinds of indexes by default: B-Tree indexes, R-Tree indexes, and
      GiST indexes.</p><div class="itemizedlist"><ul type="disc"><li><p>B-Trees are used for data which can be sorted along one axis;
          for example, numbers, letters, dates. GIS data cannot be rationally
          sorted along one axis (which is greater, (0,0) or (0,1) or (1,0)?)
          so B-Tree indexing is of no use for us.</p></li><li><p>R-Trees break up data into rectangles, and sub-rectangles, and
          sub-sub rectangles, etc. R-Trees are used by some spatial databases
          to index GIS data, but the PostgreSQL R-Tree implementation is not
          as robust as the GiST implementation.</p></li><li><p>GiST (Generalized Search Trees) indexes break up data into
          "things to one side", "things which overlap",
          "things which are inside" and can be used on a wide range of
          data-types, including GIS data. PostGIS uses an R-Tree index
          implemented on top of GiST to index GIS data.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304654"></a>4.5.1. GiST Indexes</h3></div></div></div><p>GiST stands for "Generalized Search Tree" and is a
        generic form of indexing. In addition to GIS indexing, GiST is used to
        speed up searches on all kinds of irregular data structures (integer
        arrays, spectral data, etc) which are not amenable to normal B-Tree
        indexing.</p><p>Once a GIS data table exceeds a few thousand rows, you will want
        to build an index to speed up spatial searches of the data (unless all
        your searches are based on attributes, in which case you'll want
        to build a normal index on the attribute fields).</p><p>The syntax for building a GiST index on a "geometry"
        column is as follows:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] ); </pre><p>Building a spatial index is a computationally intensive
        exercise: on tables of around 1 million rows, on a 300MHz Solaris
        machine, we have found building a GiST index takes about 1 hour. After
        building an index, it is important to force PostgreSQL to collect
        table statistics, which are used to optimize query plans:</p><pre class="programlisting">VACUUM ANALYZE [table_name] [column_name]; 
-- This is only needed for PostgreSQL 7.4 installations and below 
SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);</pre><p>GiST indexes have two advantages over R-Tree indexes in
        PostgreSQL. Firstly, GiST indexes are "null safe", meaning
        they can index columns which include null values. Secondly, GiST
        indexes support the concept of "lossiness" which is important
        when dealing with GIS objects larger than the PostgreSQL 8K page size.
        Lossiness allows PostgreSQL to store only the "important" part
        of an object in an index -- in the case of GIS objects, just the
        bounding box. GIS objects larger than 8K will cause R-Tree indexes to
        fail in the process of being built.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304709"></a>4.5.2. Using Indexes</h3></div></div></div><p>Ordinarily, indexes invisibly speed up data access: once the
        index is built, the query planner transparently decides when to use
        index information to speed up a query plan. Unfortunately, the
        PostgreSQL query planner does not optimize the use of GiST indexes
        well, so sometimes searches which should use a spatial index instead
        default to a sequence scan of the whole table.</p><p>If you find your spatial indexes are not being used (or your
        attribute indexes, for that matter) there are a couple things you can
        do:</p><div class="itemizedlist"><ul type="disc"><li><p>Firstly, make sure statistics are gathered about the number
            and distributions of values in a table, to provide the query
            planner with better information to make decisions around index
            usage. For PostgreSQL 7.4 installations and below this is done by
            running <span class="command"><strong>update_geometry_stats([table_name, column_name])</strong></span>
            (compute distribution) and <span class="command"><strong>VACUUM ANALYZE [table_name]
            [column_name]</strong></span> (compute number of values). Starting with
            PostgreSQL 8.0 running <span class="command"><strong>VACUUM ANALYZE</strong></span> will do
            both operations. You should regularly vacuum your databases
            anyways -- many PostgreSQL DBAs have <span class="command"><strong>VACUUM</strong></span> run
            as an off-peak cron job on a regular basis.</p></li><li><p>If vacuuming does not work, you can force the planner to use
            the index information by using the <span class="command"><strong>SET ENABLE_SEQSCAN=OFF</strong></span>
            command. You should only use this command sparingly, and only on
            spatially indexed queries: generally speaking, the planner knows
            better than you do about when to use normal B-Tree indexes. Once
            you have run your query, you should consider setting
            <code class="varname">ENABLE_SEQSCAN</code> back on, so that other queries
            will utilize the planner as normal.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As of version 0.6, it should not be necessary to force the
              planner to use the index with <code class="varname">ENABLE_SEQSCAN</code>.</p></div></li><li><p>If you find the planner wrong about the cost of sequential
            vs index scans try reducing the value of random_page_cost in
            postgresql.conf or using SET random_page_cost=#. Default value for
            the parameter is 4, try setting it to 1 or 2. Decrementing the
            value makes the planner more inclined of using Index scans.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id304803"></a>4.6. Complex Queries</h2></div></div></div><p>The <span class="emphasis"><em>raison d'etre</em></span> of spatial database
      functionality is performing queries inside the database which would
      ordinarily require desktop GIS functionality. Using PostGIS effectively
      requires knowing what spatial functions are available, and ensuring that
      appropriate indexes are in place to provide good performance.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304818"></a>4.6.1. Taking Advantage of Indexes</h3></div></div></div><p>When constructing a query it is important to remember that only
        the bounding-box-based operators such as &amp;&amp; can take advantage
        of the GiST spatial index. Functions such as <code class="varname">distance()</code>
        cannot use the index to optimize their operation. For example, the
        following query would be quite slow on a large table:</p><pre class="programlisting">SELECT the_geom 
FROM geom_table 
WHERE ST_Distance(the_geom, GeomFromText('POINT(100000 200000)', -1)) &lt; 100</pre><p>This query is selecting all the geometries in geom_table which
        are within 100 units of the point (100000, 200000). It will be slow
        because it is calculating the distance between each point in the table
        and our specified point, ie. one <code class="varname">ST_Distance()</code>
        calculation for each row in the table. We can avoid this by using the
        &amp;&amp; operator to reduce the number of distance calculations
        required:</p><pre class="programlisting">SELECT the_geom 
FROM geom_table 
WHERE the_geom &amp;&amp; 'BOX3D(90900 190900, 100100 200100)'::box3d 
  AND
ST_Distance(the_geom, GeomFromText('POINT(100000 200000)', -1)) &lt; 100</pre><p>This query selects the same geometries, but it does it in a more
        efficient way. Assuming there is a GiST index on the_geom, the query
        planner will recognize that it can use the index to reduce the number
        of rows before calculating the result of the <code class="varname">distance()</code>
        function. Notice that the <code class="varname">BOX3D</code> geometry which is
        used in the &amp;&amp; operation is a 200 unit square box centered on
        the original point - this is our "query box". The &amp;&amp;
        operator uses the index to quickly reduce the result set down to only
        those geometries which have bounding boxes that overlap the "query
        box". Assuming that our query box is much smaller than the extents
        of the entire geometry table, this will drastically reduce the number
        of distance calculations that need to be done.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Change in Behavior</h3><p>As of PostGIS 1.3.0, most of the Geometry
        Relationship Functions, with the notable exceptions of ST_Disjoint and
        ST_Relate, include implicit bounding box overlap operators.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id304890"></a>4.6.2. Examples of Spatial SQL</h3></div></div></div><p>The examples in this section will make use of two tables, a
        table of linear roads, and a table of polygonal municipality
        boundaries. The table definitions for the <code class="varname">bc_roads</code>
        table is:</p><pre class="programlisting">Column      | Type              | Description
------------+-------------------+------------------- 
gid         | integer           | Unique ID 
name        | character varying | Road Name 
the_geom    | geometry          | Location Geometry (Linestring)</pre><p>The table definition for the <code class="varname">bc_municipality</code>
        table is:</p><pre class="programlisting">Column     | Type              | Description
-----------+-------------------+------------------- 
gid        | integer           | Unique ID 
code       | integer           | Unique ID 
name       | character varying | City / Town Name 
the_geom   | geometry          | Location Geometry (Polygon)</pre><div class="qandaset"><dl><dt>4.6.2.1. <a href="#id304927">What is the total length of all roads, expressed in
              kilometers?</a></dt><dt>4.6.2.2. <a href="#id304951">How large is the city of Prince George, in hectares?</a></dt><dt>4.6.2.3. <a href="#id304975">What is the largest municipality in the province, by area?</a></dt><dt>4.6.2.4. <a href="#id305010">What is the length of roads fully contained within each
              municipality?</a></dt><dt>4.6.2.5. <a href="#id305046">Create a new table with all the roads within the city of
              Prince George.</a></dt><dt>4.6.2.6. <a href="#id305074">What is the length in kilometers of "Douglas St"
              in Victoria?</a></dt><dt>4.6.2.7. <a href="#id305095">What is the largest municipality polygon that has a hole?</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id304927"></a><a name="id304930"></a><p><b>4.6.2.1.</b></p></td><td align="left" valign="top"><p>What is the total length of all roads, expressed in
              kilometers?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>You can answer this question with a very simple piece of
              SQL:</p><pre class="programlisting">SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads; 

km_roads 
------------------
70842.1243039643 
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id304951"></a><a name="id304954"></a><p><b>4.6.2.2.</b></p></td><td align="left" valign="top"><p>How large is the city of Prince George, in hectares?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This query combines an attribute condition (on the
              municipality name) with a spatial calculation (of the area):</p><pre class="programlisting">SELECT 
  ST_Area(the_geom)/10000 AS hectares 
FROM bc_municipality 
WHERE name = 'PRINCE GEORGE'; 

hectares 
------------------ 
32657.9103824927 
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id304975"></a><a name="id304977"></a><p><b>4.6.2.3.</b></p></td><td align="left" valign="top"><p>What is the largest municipality in the province, by area?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This query brings a spatial measurement into the query
              condition. There are several ways of approaching this problem,
              but the most efficient is below:</p><pre class="programlisting">SELECT 
  name, 
  ST_Area(the_geom)/10000 AS hectares 
FROM 
  bc_municipality 
ORDER BY hectares DESC 
LIMIT 1;

name           | hectares 
---------------+----------------- 
TUMBLER RIDGE  | 155020.02556131 
(1 row)</pre><p>Note that in order to answer this query we have to
              calculate the area of every polygon. If we were doing this a lot
              it would make sense to add an area column to the table that we
              could separately index for performance. By ordering the results
              in a descending direction, and them using the PostgreSQL
              "LIMIT" command we can easily pick off the largest value
              without using an aggregate function like max().</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id305010"></a><a name="id305012"></a><p><b>4.6.2.4.</b></p></td><td align="left" valign="top"><p>What is the length of roads fully contained within each
              municipality?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This is an example of a "spatial join", because we
              are bringing together data from two tables (doing a join) but
              using a spatial interaction condition ("contained") as
              the join condition rather than the usual relational approach of
              joining on a common key:</p><pre class="programlisting">SELECT 
  m.name, 
  sum(ST_Length(r.the_geom))/1000 as roads_km 
FROM 
  bc_roads AS r,  
  bc_municipality AS m 
WHERE
  ST_Contains(m.the_geom,r.the_geom) 
GROUP BY m.name 
ORDER BY roads_km; 

name                        | roads_km
----------------------------+------------------ 
SURREY                      | 1539.47553551242 
VANCOUVER                   | 1450.33093486576 
LANGLEY DISTRICT            | 833.793392535662 
BURNABY                     | 773.769091404338 
PRINCE GEORGE               | 694.37554369147 
...</pre><p>This query takes a while, because every road in the table
              is summarized into the final result (about 250K roads for our
              particular example table). For smaller overlays (several
              thousand records on several hundred) the response can be very
              fast.</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id305046"></a><a name="id305048"></a><p><b>4.6.2.5.</b></p></td><td align="left" valign="top"><p>Create a new table with all the roads within the city of
              Prince George.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This is an example of an "overlay", which takes in
              two tables and outputs a new table that consists of spatially
              clipped or cut resultants. Unlike the "spatial join"
              demonstrated above, this query actually creates new geometries.
              An overlay is like a turbo-charged spatial join, and is useful
              for more exact analysis work:</p><pre class="programlisting">CREATE TABLE pg_roads as 
SELECT 
  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,
  ST_Length(r.the_geom) AS rd_orig_length, 
  r.* 
FROM 
  bc_roads AS r, 
  bc_municipality AS m 
WHERE ST_Intersects(r.the_geom, m.the_geom)
  AND m.name = 'PRINCE GEORGE';</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id305074"></a><a name="id305076"></a><p><b>4.6.2.6.</b></p></td><td align="left" valign="top"><p>What is the length in kilometers of "Douglas St"
              in Victoria?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT 
  sum(ST_Length(r.the_geom))/1000 AS kilometers 
FROM 
  bc_roads r, 
  bc_municipality m 
WHERE ST_Contains(m.the_geom, r.the_geom) 
  AND r.name = 'Douglas St' 
  AND m.name = 'VICTORIA'; 

kilometers 
------------------
4.89151904172838 
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id305095"></a><a name="id305097"></a><p><b>4.6.2.7.</b></p></td><td align="left" valign="top"><p>What is the largest municipality polygon that has a hole?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT gid, name, ST_Area(the_geom) AS area 
FROM bc_municipality 
WHERE ST_NRings(the_geom) &gt; 1 
ORDER BY area DESC LIMIT 1; 

gid  | name         | area
-----+--------------+------------------ 
12   | SPALLUMCHEEN | 257374619.430216 
(1 row)</pre></td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305122"></a>4.7. Using Mapserver</h2></div></div></div><p>The Minnesota Mapserver is an internet web-mapping server which
      conforms to the OpenGIS Web Mapping Server specification.</p><div class="itemizedlist"><ul type="disc"><li><p>The Mapserver homepage is at <a class="ulink" href="http://mapserver.gis.umn.edu" target="_top">http://mapserver.gis.umn.edu</a>.</p></li><li><p>The OpenGIS Web Map Specification is at <a class="ulink" href="http://www.opengis.org/techno/specs/01-047r2.pdf" target="_top">http://www.opengis.org/techno/specs/01-047r2.pdf</a>.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305159"></a>4.7.1. Basic Usage</h3></div></div></div><p>To use PostGIS with Mapserver, you will need to know about how
        to configure Mapserver, which is beyond the scope of this
        documentation. This section will cover specific PostGIS issues and
        configuration details.</p><p>To use PostGIS with Mapserver, you will need:</p><div class="itemizedlist"><ul type="disc"><li><p>Version 0.6 or newer of PostGIS.</p></li><li><p>Version 3.5 or newer of Mapserver.</p></li></ul></div><p>Mapserver accesses PostGIS/PostgreSQL data like any other
        PostgreSQL client -- using <code class="filename">libpq</code>. This means that
        Mapserver can be installed on any machine with network access to the
        PostGIS server, as long as the system has the <code class="filename">libpq</code>
        PostgreSQL client libraries.</p><div class="orderedlist"><ol type="1"><li><p>Compile and install Mapserver, with whatever options you
            desire, including the "--with-postgis" configuration
            option.</p></li><li><p>In your Mapserver map file, add a PostGIS layer. For
            example:</p><pre class="programlisting">LAYER 
  CONNECTIONTYPE postgis 
  NAME "widehighways" 
  # Connect to a remote spatial database
  CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
  # Get the lines from the 'geom' column of the 'roads' table 
  DATA "geom from roads" 
  STATUS ON
  TYPE LINE 
  # Of the lines in the extents, only render the wide highways 
  FILTER "type = 'highway' and numlanes &gt;= 4" 
  CLASS 
    # Make the superhighways brighter and 2 pixels wide
    EXPRESSION ([numlanes] &gt;= 6) 
    COLOR 255 22 22 
    SYMBOL "solid" 
    SIZE 2 
  END 
  CLASS 
    # All the rest are darker and only 1 pixel wide 
    EXPRESSION ([numlanes] &lt; 6) 
    COLOR 205 92 82
  END 
END</pre><p>In the example above, the PostGIS-specific directives are as
            follows:</p><div class="variablelist"><dl><dt><span class="term">CONNECTIONTYPE</span></dt><dd><p>For PostGIS layers, this is always "postgis".</p></dd><dt><span class="term">CONNECTION</span></dt><dd><p>The database connection is governed by the a
                  'connection string' which is a standard set of keys
                  and values like this (with the default values in
                  &lt;&gt;):</p><p>user=&lt;username&gt; password=&lt;password&gt;
                  dbname=&lt;username&gt; hostname=&lt;server&gt;
                  port=&lt;5432&gt;</p><p>An empty connection string is still valid, and any of
                  the key/value pairs can be omitted. At a minimum you will
                  generally supply the database name and username to connect
                  with.</p></dd><dt><span class="term">DATA</span></dt><dd><p>The form of this parameter is "&lt;column&gt;
                  from &lt;tablename&gt;" where the column is the
                  spatial column to be rendered to the map.</p></dd><dt><span class="term">FILTER</span></dt><dd><p>The filter must be a valid SQL string corresponding to
                  the logic normally following the "WHERE" keyword in
                  a SQL query. So, for example, to render only roads with 6 or
                  more lanes, use a filter of "num_lanes &gt;= 6".</p></dd></dl></div></li><li><p>In your spatial database, ensure you have spatial (GiST)
            indexes built for any the layers you will be drawing.</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometrycolumn] );</pre></li><li><p>If you will be querying your layers using Mapserver you will
            also need an "oid index".</p><p>Mapserver requires unique identifiers for each spatial
            record when doing queries, and the PostGIS module of Mapserver
            uses the PostgreSQL <code class="varname">oid</code> value to provide these
            unique identifiers. A side-effect of this is that in order to do
            fast random access of records during queries, an index on the
            <code class="varname">oid</code> is needed.</p><p>To build an "oid index", use the following SQL:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] ( oid );</pre></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305366"></a>4.7.2. Frequently Asked Questions</h3></div></div></div><div class="qandaset"><dl><dt>4.7.2.1. <a href="#id305374">When I use an EXPRESSION in my map
              file, the condition never returns as true, even though I know
              the values exist in my table.</a></dt><dt>4.7.2.2. <a href="#id305403">The FILTER I use for my Shape files is not working for my
              PostGIS table of the same data.</a></dt><dt>4.7.2.3. <a href="#id305428">My PostGIS layer draws much slower than my Shape file
              layer, is this normal?</a></dt><dt>4.7.2.4. <a href="#id305460">My PostGIS layer draws fine, but queries are really slow.
              What is wrong?</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id305374"></a><a name="id305376"></a><p><b>4.7.2.1.</b></p></td><td align="left" valign="top"><p>When I use an <code class="varname">EXPRESSION</code> in my map
              file, the condition never returns as true, even though I know
              the values exist in my table.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Unlike shape files, PostGIS field names have to be
              referenced in EXPRESSIONS using <span class="emphasis"><em>lower case</em></span>.</p><pre class="programlisting">EXPRESSION ([numlanes] &gt;= 6)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id305403"></a><a name="id305406"></a><p><b>4.7.2.2.</b></p></td><td align="left" valign="top"><p>The FILTER I use for my Shape files is not working for my
              PostGIS table of the same data.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Unlike shape files, filters for PostGIS layers use SQL
              syntax (they are appended to the SQL statement the PostGIS
              connector generates for drawing layers in Mapserver).</p><pre class="programlisting">FILTER "type = 'highway' and numlanes &gt;= 4"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id305428"></a><a name="id305430"></a><p><b>4.7.2.3.</b></p></td><td align="left" valign="top"><p>My PostGIS layer draws much slower than my Shape file
              layer, is this normal?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>In general, expect PostGIS layers to be 10% slower than
              equivalent Shape files layers, due to the extra overhead
              involved in database connections, data transformations and data
              transit between the database and Mapserver.</p><p>If you are finding substantial draw performance problems,
              it is likely that you have not build a spatial index on your
              table.</p><pre class="programlisting">postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn ); 
postgis# SELECT update_geometry_stats(); -- For PGSQL &lt; 8.0 
postgis# VACUUM ANALYZE; -- For PGSQL &gt;= 8.0</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id305460"></a><a name="id305462"></a><p><b>4.7.2.4.</b></p></td><td align="left" valign="top"><p>My PostGIS layer draws fine, but queries are really slow.
              What is wrong?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>For queries to be fast, you must have a unique key for
              your spatial table and you must have an index on that unique
              key.</p><p>You can specify what unique key for mapserver to use with
              the <code class="varname">USING UNIQUE</code> clause in your
              <code class="varname">DATA</code> line:</p><pre class="programlisting">DATA "the_geom FROM geotable USING UNIQUE gid"</pre><p>If your table does not have an explicit unique column, you
              can "fake" a unique column by using the PostgreSQL row
              "oid" for your unique column. "oid" is the
              default unique column if you do not declare one, so enhancing
              your query speed is a matter of building an index on your
              spatial table oid value.</p><pre class="programlisting">postgis# CREATE INDEX geotable_oid_idx ON geotable (oid);</pre></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305515"></a>4.7.3. Advanced Usage</h3></div></div></div><p>The <code class="varname">USING</code> pseudo-SQL clause is used to add
        some information to help mapserver understand the results of more
        complex queries. More specifically, when either a view or a subselect
        is used as the source table (the thing to the right of "FROM"
        in a <code class="varname">DATA</code> definition) it is more difficult for
        mapserver to automatically determine a unique identifier for each row
        and also the SRID for the table. The <code class="varname">USING</code> clause
        can provide mapserver with these two pieces of information as follows:</p><pre class="programlisting">DATA "the_geom FROM (
  SELECT 
    table1.the_geom AS the_geom, 
    table1.oid AS oid, 
    table2.data AS data 
  FROM table1 
  LEFT JOIN table2 
  ON table1.id = table2.id
) AS new_table USING UNIQUE oid USING SRID=-1"</pre><div class="variablelist"><dl><dt><span class="term">USING UNIQUE &lt;uniqueid&gt;</span></dt><dd><p>Mapserver requires a unique id for each row in order to
              identify the row when doing map queries. Normally, it would use
              the oid as the unique identifier, but views and subselects
              don't automatically have an oid column. If you want to use
              Mapserver's query functionality, you need to add a unique
              column to your view or subselect, and declare it with
              <code class="varname">USING UNIQUE</code>. For example, you could
              explicitly select one of the table's oid values for this
              purpose, or any other column which is guaranteed to be unique
              for the result set.</p><p>The <code class="varname">USING</code> statement can also be useful
              even for simple <code class="varname">DATA</code> statements, if you are
              doing map queries. It was previously recommended to add an index
              on the oid column of tables used in query-able layers, in order
              to speed up the performance of map queries. However, with the
              <code class="varname">USING</code> clause, it is possible to tell
              mapserver to use your table's primary key as the identifier
              for map queries, and then it is no longer necessary to have an
              additional index.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>"Querying a Map" is the action of clicking on a
                map to ask for information about the map features in that
                location. Don't confuse "map queries" with the SQL
                query in a <code class="varname">DATA</code> definition.</p></div></dd><dt><span class="term">USING SRID=&lt;srid&gt;</span></dt><dd><p>PostGIS needs to know which spatial referencing system is
              being used by the geometries in order to return the correct data
              back to mapserver. Normally it is possible to find this
              information in the "geometry_columns" table in the
              PostGIS database, however, this is not possible for tables which
              are created on the fly such as subselects and views. So the
              <code class="varname">USING SRID=</code> option allows the correct SRID to
              be specified in the <code class="varname">DATA</code> definition.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>The parser for Mapserver PostGIS layers is fairly primitive,
          and is case sensitive in a few areas. Be careful to ensure that all
          SQL keywords and all your <code class="varname">USING</code> clauses are in
          upper case, and that your <code class="varname">USING UNIQUE</code> clause
          precedes your <code class="varname">USING SRID</code> clause.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305647"></a>4.7.4. Examples</h3></div></div></div><p>Lets start with a simple example and work our way up. Consider
        the following Mapserver layer definition:</p><pre class="programlisting">LAYER 
  CONNECTIONTYPE postgis 
  NAME "roads"
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver" 
  DATA "the_geom FROM roads" 
  STATUS ON 
  TYPE LINE 
  CLASS 
    COLOR 0 0 0 
  END 
END</pre><p>This layer will display all the road geometries in the roads
        table as black lines.</p><p>Now lets say we want to show only the highways until we get
        zoomed in to at least a 1:100000 scale - the next two layers will
        achieve this effect:</p><pre class="programlisting">LAYER 
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver" 
  DATA "the_geom FROM roads"
  MINSCALE 100000 
  STATUS ON 
  TYPE LINE 
  FILTER "road_type = 'highway'" 
  CLASS 
    COLOR 0 0 0 
  END 
END 
LAYER 
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  DATA "the_geom FROM roads" 
  MAXSCALE 100000 
  STATUS ON 
  TYPE LINE
  CLASSITEM road_type 
  CLASS 
    EXPRESSION "highway" 
    SIZE 2 
    COLOR 255 0 0  
  END 
  CLASS  
    COLOR 0 0 0 
  END 
END</pre><p>The first layer is used when the scale is greater than 1:100000,
        and displays only the roads of type "highway" as black lines.
        The <code class="varname">FILTER</code> option causes only roads of type
        "highway" to be displayed.</p><p>The second layer is used when the scale is less than 1:100000,
        and will display highways as double-thick red lines, and other roads
        as regular black lines.</p><p>So, we have done a couple of interesting things using only
        mapserver functionality, but our <code class="varname">DATA</code> SQL statement
        has remained simple. Suppose that the name of the road is stored in
        another table (for whatever reason) and we need to do a join to get it
        and label our roads.</p><pre class="programlisting">LAYER 
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver" 
  DATA "the_geom FROM (SELECT roads.oid AS oid, roads.the_geom AS the_geom, 
        road_names.name as name FROM roads LEFT JOIN road_names ON 
        roads.road_name_id = road_names.road_name_id) 
        AS named_roads USING UNIQUE oid USING SRID=-1" 
  MAXSCALE 20000 
  STATUS ON 
  TYPE ANNOTATION 
  LABELITEM name
  CLASS 
    LABEL 
      ANGLE auto 
      SIZE 8 
      COLOR 0 192 0 
      TYPE truetype 
      FONT arial
    ENDl
  END 
END</pre><p>This annotation layer adds green labels to all the roads when
        the scale gets down to 1:20000 or less. It also demonstrates how to
        use an SQL join in a <code class="varname">DATA</code> definition.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305728"></a>4.8. Java Clients (JDBC)</h2></div></div></div><p>Java clients can access PostGIS "geometry" objects in the
      PostgreSQL database either directly as text representations or using the
      JDBC extension objects bundled with PostGIS. In order to use the
      extension objects, the "postgis.jar" file must be in your
      CLASSPATH along with the "postgresql.jar" JDBC driver package.</p><pre class="programlisting">import java.sql.*; 
import java.util.*; 
import java.lang.*; 
import org.postgis.*; 

public class JavaGIS { 

public static void main(String[] args) { 

  java.sql.Connection conn; 

  try { 
    /* 
    * Load the JDBC driver and establish a connection. 
    */
    Class.forName("org.postgresql.Driver"); 
    String url = "jdbc:postgresql://localhost:5432/database"; 
    conn = DriverManager.getConnection(url, "postgres", ""); 
    /* 
    * Add the geometry types to the connection. Note that you 
    * must cast the connection to the pgsql-specific connection 
    * implementation before calling the addDataType() method. 
    */
    ((org.postgresql.Connection)conn).addDataType("geometry","org.postgis.PGgeometry")
;
    ((org.postgresql.Connection)conn).addDataType("box3d","org.postgis.PGbox3d");
    /* 
    * Create a statement and execute a select query. 
    */ 
    Statement s = conn.createStatement(); 
    ResultSet r = s.executeQuery("select AsText(geom) as geom,id from geomtable"); 
    while( r.next() ) { 
      /* 
      * Retrieve the geometry as an object then cast it to the geometry type. 
      * Print things out. 
      */ 
      PGgeometry geom = (PGgeometry)r.getObject(1); 
      int id = r.getInt(2); 
      System.out.println("Row " + id + ":");
      System.out.println(geom.toString()); 
    } 
    s.close(); 
    conn.close(); 
  } 
catch( Exception e ) { 
  e.printStackTrace(); 
  } 
} 
}</pre><p>The "PGgeometry" object is a wrapper object which contains
      a specific topological geometry object (subclasses of the abstract class
      "Geometry") depending on the type: Point, LineString, Polygon,
      MultiPoint, MultiLineString, MultiPolygon.</p><pre class="programlisting">PGgeometry geom = (PGgeometry)r.getObject(1); 
if( geom.getType() = Geometry.POLYGON ) { 
  Polygon pl = (Polygon)geom.getGeometry(); 
  for( int r = 0; r &lt; pl.numRings(); r++) { 
    LinearRing rng = pl.getRing(r); 
    System.out.println("Ring: " + r); 
    for( int p = 0; p &lt; rng.numPoints(); p++ ) { 
      Point pt = rng.getPoint(p); 
      System.out.println("Point: " + p);
      System.out.println(pt.toString()); 
    } 
  } 
}</pre><p>The JavaDoc for the extension objects provides a reference for the
      various data accessor functions in the geometric objects.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305784"></a>4.9. C Clients (libpq)</h2></div></div></div><p>...</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305793"></a>4.9.1. Text Cursors</h3></div></div></div><p>...</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305802"></a>4.9.2. Binary Cursors</h3></div></div></div><p>...</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id305814"></a>Chapter 5. Performance tips</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id305819">5.1. Small tables of large geometries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id305825">5.1.1. Problem description</a></span></dt><dt><span class="sect2"><a href="#id305872">5.1.2. Workarounds</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id305929">5.2. CLUSTERing on geometry indices</a></span></dt><dt><span class="sect1"><a href="#id305981">5.3. Avoiding dimension conversion</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305819"></a>5.1. Small tables of large geometries</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305825"></a>5.1.1. Problem description</h3></div></div></div><p>Current PostgreSQL versions (including 8.0) suffer from a query
        optimizer weakness regarding TOAST tables. TOAST tables are a kind of
        "extension room" used to store large (in the sense of data
        size) values that do not fit into normal data pages (like long texts,
        images or complex geometries with lots of vertices), see
        http://www.postgresql.org/docs/8.0/static/storage-toast.html for more
        information).</p><p>The problem appears if you happen to have a table with rather
        large geometries, but not too much rows of them (like a table
        containing the boundaries of all European countries in high
        resolution). Then the table itself is small, but it uses lots of TOAST
        space. In our example case, the table itself had about 80 rows and
        used only 3 data pages, but the TOAST table used 8225 pages.</p><p>Now issue a query where you use the geometry operator &amp;&amp;
        to search for a bounding box that matches only very few of those rows.
        Now the query optimizer sees that the table has only 3 pages and 80
        rows. He estimates that a sequential scan on such a small table is
        much faster than using an index. And so he decides to ignore the GIST
        index. Usually, this estimation is correct. But in our case, the
        &amp;&amp; operator has to fetch every geometry from disk to compare
        the bounding boxes, thus reading all TOAST pages, too.</p><p>To see whether your suffer from this bug, use the "EXPLAIN
        ANALYZE" postgresql command. For more information and the
        technical details, you can read the thread on the postgres performance
        mailing list:
        http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id305872"></a>5.1.2. Workarounds</h3></div></div></div><p>The PostgreSQL people are trying to solve this issue by making
        the query estimation TOAST-aware. For now, here are two workarounds:</p><p>The first workaround is to force the query planner to use the
        index. Send "SET enable_seqscan TO off;" to the server before
        issuing the query. This basically forces the query planner to avoid
        sequential scans whenever possible. So it uses the GIST index as
        usual. But this flag has to be set on every connection, and it causes
        the query planner to make misestimations in other cases, so you should
        "SET enable_seqscan TO on;" after the query.</p><p>The second workaround is to make the sequential scan as fast as
        the query planner thinks. This can be achieved by creating an
        additional column that "caches" the bbox, and matching against
        this. In our example, the commands are like:</p><pre class="programlisting">SELECT addGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2'); 
UPDATE mytable set bbox = Envelope(Force_2d(the_geom));</pre><p>Now change your query to use the &amp;&amp; operator against
        bbox instead of geom_column, like:</p><pre class="programlisting">SELECT geom_column 
FROM mytable 
WHERE bbox &amp;&amp; ST_SetSRID('BOX3D(0 0,1 1)'::box3d,4326);</pre><p>Of course, if you change or add rows to mytable, you have to
        keep the bbox "in sync". The most transparent way to do this
        would be triggers, but you also can modify your application to keep
        the bbox column current or run the UPDATE query above after every
        modification.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305929"></a>5.2. CLUSTERing on geometry indices</h2></div></div></div><p>For tables that are mostly read-only, and where a single index is
      used for the majority of queries, PostgreSQL offers the CLUSTER command.
      This command physically reorders all the data rows in the same order as
      the index criteria, yielding two performance advantages: First, for
      index range scans, the number of seeks on the data table is drastically
      reduced. Second, if your working set concentrates to some small
      intervals on the indices, you have a more efficient caching because the
      data rows are spread along fewer data pages. (Feel invited to read the
      CLUSTER command documentation from the PostgreSQL manual at this point.)</p><p>However, currently PostgreSQL does not allow clustering on PostGIS
      GIST indices because GIST indices simply ignores NULL values, you get an
      error message like:</p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table; 
ERROR: cannot cluster when index access method does not handle null values
HINT: You may be able to work around this by marking column "the_geom" NOT NULL.</pre><p>As the HINT message tells you, one can work around this deficiency
      by adding a "not null" constraint to the table:</p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null; 
ALTER TABLE</pre><p>Of course, this will not work if you in fact need NULL values in
      your geometry column. Additionally, you must use the above method to add
      the constraint, using a CHECK constraint like "ALTER TABLE blubb ADD
      CHECK (geometry is not null);" will not work.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id305981"></a>5.3. Avoiding dimension conversion</h2></div></div></div><p>Sometimes, you happen to have 3D or 4D data in your table, but
      always access it using OpenGIS compliant asText() or asBinary()
      functions that only output 2D geometries. They do this by internally
      calling the force_2d() function, which introduces a significant overhead
      for large geometries. To avoid this overhead, it may be feasible to
      pre-drop those additional dimensions once and forever:</p><pre class="programlisting">UPDATE mytable SET the_geom = force_2d(the_geom); 
VACUUM FULL ANALYZE mytable;</pre><p>Note that if you added your geometry column using
      AddGeometryColumn() there'll be a constraint on geometry dimension.
      To bypass it you will need to drop the constraint. Remember to update
      the entry in the geometry_columns table and recreate the constraint
      afterwards.</p><p>In case of large tables, it may be wise to divide this UPDATE into
      smaller portions by constraining the UPDATE to a part of the table via a
      WHERE clause and your primary key or another feasible criteria, and
      running a simple "VACUUM;" between your UPDATEs. This
      drastically reduces the need for temporary disk space. Additionally, if
      you have mixed dimension geometries, restricting the UPDATE by
      "WHERE dimension(the_geom)&gt;2" skips re-writing of geometries
      that already are in 2D.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id306019"></a>Chapter 6. PostGIS Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id306040">6.1. OpenGIS Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id306045">6.1.1. Management Functions</a></span></dt><dt><span class="sect2"><a href="#id306118">6.1.2. Geometry Relationship Functions</a></span></dt><dt><span class="sect2"><a href="#id306540">6.1.3. Geometry Processing Functions</a></span></dt><dt><span class="sect2"><a href="#id306824">6.1.4. Geometry Accessors</a></span></dt><dt><span class="sect2"><a href="#id307284">6.1.5. Geometry Constructors</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id307799">6.2. PostGIS Extensions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id307804">6.2.1. Management Functions</a></span></dt><dt><span class="sect2"><a href="#id308090">6.2.2. Operators</a></span></dt><dt><span class="sect2"><a href="#id308280">6.2.3. Measurement Functions</a></span></dt><dt><span class="sect2"><a href="#id308525">6.2.4. Geometry Outputs</a></span></dt><dt><span class="sect2"><a href="#id308642">6.2.5. Geometry Constructors</a></span></dt><dt><span class="sect2"><a href="#id258133">6.2.6. Geometry Editors</a></span></dt><dt><span class="sect2"><a href="#id309528">6.2.7. Linear Referencing</a></span></dt><dt><span class="sect2"><a href="#id309708">6.2.8. Misc</a></span></dt><dt><span class="sect2"><a href="#id310341">6.2.9. Long Transactions support</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id310131">6.3. SQL-MM Functions</a></span></dt><dt><span class="sect1"><a href="#id311488">6.4. ArcSDE Functions</a></span></dt></dl></div><p>The functions given below are the ones which a user of PostGIS is
    likely to need. There are other functions which are required support
    functions to the PostGIS objects which are not of use to a general user.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>PostGIS has begun a transition from the existing naming convention
      to an SQL-MM-centric convention. As a result, most of the functions that
      you know and love have been renamed using the standard spatial type (ST)
      prefix. Previous functions are still available, though are not listed in
      this document where updated functions are equivalent. These will be
      deprecated in a future release.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id306040"></a>6.1. OpenGIS Functions</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id306045"></a>6.1.1. Management Functions</h3></div></div></div><div class="variablelist"><dl><dt><a name="AddGeometryColumn"></a><span class="term">AddGeometryColumn(varchar, varchar, varchar, integer,
            varchar, integer)</span></dt><dd><p>Syntax: AddGeometryColumn(&lt;schema_name&gt;,
              &lt;table_name&gt;, &lt;column_name&gt;, &lt;srid&gt;,
              &lt;type&gt;, &lt;dimension&gt;). Adds a geometry column to
              an existing table of attributes. The <code class="varname">schema_name</code>
              is the name of the table schema (unused for pre-schema
              PostgreSQL installations). The <code class="varname">srid</code> must be
              an integer value reference to an entry in the SPATIAL_REF_SYS
              table. The <code class="varname">type</code> must be an uppercase string
              corresponding to the geometry type, eg, 'POLYGON' or
              'MULTILINESTRING'.</p></dd><dt><span class="term">DropGeometryColumn(varchar, varchar, varchar)</span></dt><dd><p>Syntax: DropGeometryColumn(&lt;schema_name&gt;,
              &lt;table_name&gt;, &lt;column_name&gt;). Remove a geometry
              column from a spatial table. Note that schema_name will need to
              match the f_schema_name field of the table's row in the
              geometry_columns table.</p></dd><dt><span class="term">ST_SetSRID(geometry, integer)</span></dt><dd><p>Set the SRID on a geometry to a particular integer value.
              Useful in constructing bounding boxes for queries.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id306118"></a>6.1.2. Geometry Relationship Functions</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_Distance(geometry, geometry)</span></dt><dd><p>Return the cartesian distance between two geometries in
              projected units. Does not use indexes.</p></dd><dt><span class="term">ST_DWithin(geometry, geometry, float)</span></dt><dd><p>Returns true if geometries are within the specified distance 
              of one another. Uses indexes if available.</p></dd><dt><span class="term">ST_Equals(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the given Geometries are
              "spatially equal". Use this for a 'better'
              answer than '='. equals('LINESTRING(0 0, 10
              10)','LINESTRING(0 0, 5 5, 10 10)') is true.</p><p>Performed by the GEOS module</p><p>OGC SPEC s2.1.1.2</p></dd><dt><span class="term">ST_Disjoint(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries are "spatially
              disjoint".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 //s2.1.13.3 - a.Relate(b,
              'FF*FF****')</p></dd><dt><span class="term">ST_Intersects(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries "spatially
              intersect".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Intersects.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 //s2.1.13.3 - Intersects(g1, g2 )
              --&gt; Not (Disjoint(g1, g2 ))</p></dd><dt><span class="term">ST_Touches(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries "spatially
              touch".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Touches.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3- a.Touches(b) -&gt; (I(a)
              intersection I(b) = {empty set} ) and (a intersection b) not
              empty</p></dd><dt><span class="term">ST_Crosses(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries "spatially
              cross".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Crosses.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - a.Relate(b,
              'T*T******')</p></dd><dt><span class="term">ST_Within(geometry A, geometry B)</span></dt><dd><p>Returns 1 (TRUE) if Geometry A is "spatially
              within" Geometry B.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Within.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - a.Relate(b,
              'T*F**F***')</p></dd><dt><span class="term">ST_Overlaps(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries "spatially
              overlap".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Overlaps.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3</p></dd><dt><span class="term">ST_Contains(geometry A, geometry B)</span></dt><dd><p>Returns 1 (TRUE) if Geometry A "spatially
              contains" Geometry B.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Contains.</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - same as within(geometry
              B, geometry A)</p></dd><dt><span class="term">ST_Covers(geometry A, geometry B)</span></dt><dd><p>Returns 1 (TRUE) if no point in Geometry B is outside 
              Geometry A</p><p>Refer to http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html
              for an explanation of the need of this function.</p><p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.  To avoid index use, use the function _ST_Covers.</p></dd><dt><span class="term">ST_CoveredBy(geometry A, geometry B)</span></dt><dd><p>Returns 1 (TRUE) if no point in Geometry A is outside 
                Geometry B</p><p>Refer to http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html
              for an explaination of the need of this function.</p></dd><dt><span class="term">ST_Intersects(geometry, geometry)</span></dt><dd><p>Returns 1 (TRUE) if the Geometries "spatially
              intersect".</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - NOT disjoint(geometry,
              geometry)</p></dd><dt><span class="term">ST_Relate(geometry, geometry, intersectionPatternMatrix)</span></dt><dd><p>Returns 1 (TRUE) if this Geometry is spatially related to
              anotherGeometry, by testing for intersections between the
              Interior, Boundary and Exterior of the two geometries as
              specified by the values in the intersectionPatternMatrix.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>NOTE: this is the "allowable" version that returns
              a boolean, not an integer.</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3</p></dd><dt><span class="term">ST_Relate(geometry, geometry)</span></dt><dd><p>returns the DE-9IM (dimensionally extended
              nine-intersection matrix)</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>not in OGC spec, but implied. see s2.1.13.2</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id306540"></a>6.1.3. Geometry Processing Functions</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_Centroid(geometry)</span></dt><dd><p>Returns the centroid of the geometry as a point.</p><p>Computation will be more accurate if performed by the GEOS
              module (enabled at compile time).</p></dd><dt><span class="term">ST_Area(geometry)</span></dt><dd><p>Returns the area of the geometry if it is a polygon or
              multi-polygon.</p></dd><dt><span class="term">ST_Length(geometry)</span></dt><dd><p>The length of this Curve in its associated spatial
              reference.</p><p>synonym for length2d()</p><p>OGC SPEC 2.1.5.1</p></dd><dt><span class="term">ST_PointOnSurface(geometry)</span></dt><dd><p>Return a Point guaranteed to lie on the surface</p><p>Implemented using GEOS</p><p>OGC SPEC 3.2.14.2 and 3.2.18.2 -</p></dd><dt><span class="term">ST_Boundary(geometry)</span></dt><dd><p>Returns the closure of the combinatorial boundary of this
              Geometry. The combinatorial boundary is defined as described in
              section 3.12.3.2 of the OGC SPEC. Because the result of this
              function is a closure, and hence topologically closed, the
              resulting boundary can be represented using representational
              geometry primitives as discussed in the OGC SPEC, section
              3.12.2.</p><p>Performed by the GEOS module</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">ST_Buffer(geometry, double, [integer])</span></dt><dd><p>Returns a geometry that represents all points whose
              distance from this Geometry is less than or equal to distance.
              Calculations are in the Spatial Reference System of this
              Geometry. The optional third parameter sets the number of
              segment used to approximate a quarter circle (defaults to 8).</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_ConvexHull(geometry)</span></dt><dd><p>Returns a geometry that represents the convex hull of this
              Geometry.</p><p>Performed by the GEOS module</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_Intersection(geometry, geometry)</span></dt><dd><p>Returns a geometry that represents the point set
              intersection of the Geometries.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_SymDifference(geometry A, geometry B)</span></dt><dd><p>Returns a geometry that represents the point set symmetric
              difference of Geometry A with Geometry B.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_Difference(geometry A, geometry B)</span></dt><dd><p>Returns a geometry that represents the point set
              difference of Geometry A with Geometry B.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_Union(geometry, geometry)</span></dt><dd><p>Returns a geometry that represents the point set union of
              the Geometries.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection as an argument</p><p>NOTE: this is renamed from "union" because union
              is an SQL reserved word</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ST_Union(geometry set)</span></dt><dd><p>Returns a geometry that represents the point set union of
              this all Geometries in given set.</p><p>Performed by the GEOS module</p><p>Do not call with a GeometryCollection in the argument set</p><p>Not explicitly defined in OGC SPEC</p></dd><dt><span class="term">ST_MemUnion(geometry set)</span></dt><dd><p>Same as the above, only memory-friendly (uses less memory
              and more processor time).</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id306824"></a>6.1.4. Geometry Accessors</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_AsText(geometry)</span></dt><dd><p>Return the Well-Known Text representation of the geometry.
              For example: POLYGON(0 0,0 1,1 1,1 0,0 0)</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">ST_AsBinary(geometry)</span></dt><dd><p>Returns the geometry in the OGC
              "well-known-binary" format, using the endian encoding of
              the server on which the database is running. This is useful in
              binary cursors to pull data out of the database without
              converting it to a string representation.</p><p>OGC SPEC s2.1.1.1 - also see
              asBinary(&lt;geometry&gt;,'XDR') and
              asBinary(&lt;geometry&gt;,'NDR')</p></dd><dt><span class="term">ST_SRID(geometry)</span></dt><dd><p>Returns the integer SRID number of the spatial reference
              system of the geometry.</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">ST_Dimension(geometry)</span></dt><dd><p>The inherent dimension of this Geometry object, which must
              be less than or equal to the coordinate dimension. OGC SPEC
              s2.1.1.1 - returns 0 for points, 1 for lines, 2 for polygons,
              and the largest dimension of the components of a
              GEOMETRYCOLLECTION.</p><pre class="programlisting">select dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0)'); 
dimension 
----------- 
1</pre></dd><dt><span class="term">ST_Envelope(geometry)</span></dt><dd><p>Returns a POLYGON representing the bounding box of the
              geometry.</p><p>OGC SPEC s2.1.1.1 - The minimum bounding box for this
              Geometry, returned as a Geometry. The polygon is defined by the
              corner points of the bounding box ((MINX, MINY), (MAXX, MINY),
              (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)).</p><p>NOTE:PostGIS will add a Zmin/Zmax coordinate as well.</p></dd><dt><span class="term">ST_IsEmpty(geometry)</span></dt><dd><p>Returns 1 (TRUE) if this Geometry is the empty geometry .
              If true, then this Geometry represents the empty point set -
              i.e. GEOMETRYCOLLECTION(EMPTY).</p><p>OGC SPEC s2.1.1.1</p></dd><dt><a name="IsSimple"></a><span class="term">ST_IsSimple(geometry)</span></dt><dd><p>Returns 1 (TRUE) if this Geometry has no anomalous
              geometric points, such as self intersection or self tangency.</p><p>Performed by the GEOS module</p><p>OGC SPEC s2.1.1.1</p></dd><dt><a name="IsClosed"></a><span class="term">ST_IsClosed(geometry)</span></dt><dd><p>Returns true of the geometry start and end points are
              coincident.</p></dd><dt><span class="term">ST_IsRing(geometry)</span></dt><dd><p>Returns 1 (TRUE) if this Curve is closed (StartPoint ( ) =
              EndPoint ( )) and this Curve is simple (does not pass through
              the same point more than once).</p><p>performed by GEOS</p><p>OGC spec 2.1.5.1</p></dd><dt><span class="term">ST_NumGeometries(geometry)</span></dt><dd><p>If geometry is a GEOMETRYCOLLECTION (or MULTI*) return the
              number of geometries, otherwise return NULL.</p></dd><dt><span class="term">ST_GeometryN(geometry,int)</span></dt><dd><p>Return the N'th geometry if the geometry is a
              GEOMETRYCOLLECTION, MULTIPOINT, MULTILINESTRING or MULTIPOLYGON.
              Otherwise, return NULL.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Index is 1-based as for OGC specs since version 0.8.0.
                Previous versions implemented this as 0-based instead.</p></div></dd><dt><span class="term">ST_NumPoints(geometry)</span></dt><dd><p>Find and return the number of points in the first
              linestring in the geometry. Return NULL if there is no
              linestring in the geometry.</p></dd><dt><span class="term">ST_PointN(geometry,integer)</span></dt><dd><p>Return the N'th point in the first linestring in the
              geometry. Return NULL if there is no linestring in the geometry.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Index is 1-based as for OGC specs since version 0.8.0.
                Previous versions implemented this as 0-based instead.</p></div></dd><dt><span class="term">ST_ExteriorRing(geometry)</span></dt><dd><p>Return the exterior ring of the polygon geometry. Return
              NULL if the geometry is not a polygon.</p></dd><dt><span class="term">ST_NumInteriorRings(geometry)</span></dt><dd><p>Return the number of interior rings of the first polygon
              in the geometry. Return NULL if there is no polygon in the
              geometry.</p></dd><dt><span class="term">ST_NumInteriorRing(geometry)</span></dt><dd><p>Synonym to NumInteriorRings(geometry). The OpenGIS specs
              are ambiguous about the exact function naming, so we provide
              both spellings.</p></dd><dt><span class="term">ST_InteriorRingN(geometry,integer)</span></dt><dd><p>Return the N'th interior ring of the polygon geometry.
              Return NULL if the geometry is not a polygon or the given N is
              out of range.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Index is 1-based as for OGC specs since version 0.8.0.
                Previous versions implemented this as 0-based instead.</p></div></dd><dt><span class="term">ST_EndPoint(geometry)</span></dt><dd><p>Returns the last point of the LineString geometry as a
              point.</p></dd><dt><a name="StartPoint"></a><span class="term">ST_StartPoint(geometry)</span></dt><dd><p>Returns the first point of the LineString geometry as a
              point.</p></dd><dt><a name="GeometryType"></a><span class="term">GeometryType(geometry)</span></dt><dd><p>Returns the type of the geometry as a string. Eg:
              'LINESTRING', 'POLYGON', 'MULTIPOINT',
              etc.</p><p>OGC SPEC s2.1.1.1 - Returns the name of the instantiable
              subtype of Geometry of which this Geometry instance is a member.
              The name of the instantiable subtype of Geometry is returned as
              a string.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function also indicates if the geometry is
                measured, by returning a string of the form 'POINTM'.</p></div></dd><dt><span class="term">ST_GeometryType(geometry)</span></dt><dd><p>Returns the type of the geometry as a string. EG:
              'Linestring', 'Polygon', etc. This function
              differs from GeometryType(geometry) in the case of the string
              that is returned, as well as the fact that it will not indicate
              whether the geometry is measured.</p></dd><dt><span class="term">ST_X(geometry)</span></dt><dd><p>Return the X coordinate of the point. Input must be a
              point.</p></dd><dt><span class="term">ST_Y(geometry)</span></dt><dd><p>Return the Y coordinate of the point. Input must be a
              point.</p></dd><dt><span class="term">ST_Z(geometry)</span></dt><dd><p>Return the Z coordinate of the point, or NULL if not
              available. Input must be a point.</p></dd><dt><span class="term">ST_M(geometry)</span></dt><dd><p>Return the M coordinate of the point, or NULL if not
              available. Input must be a point.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This is not (yet) part of the OGC spec, but is listed
                here to complete the point coordinate extractor function list.</p></div></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id307284"></a>6.1.5. Geometry Constructors</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_GeomFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p></dd><dt><span class="term">ST_PointFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a Point</p></dd><dt><span class="term">ST_LineFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a Line</p></dd><dt><span class="term">ST_LinestringFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>from the conformance suite</p><p>Throws an error if the WKT is not a Line</p></dd><dt><span class="term">ST_PolyFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a Polygon</p></dd><dt><span class="term">ST_PolygonFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>from the conformance suite</p><p>Throws an error if the WKT is not a Polygon</p></dd><dt><span class="term">ST_MPointFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a MULTIPOINT</p></dd><dt><span class="term">ST_MLineFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a MULTILINESTRING</p></dd><dt><span class="term">ST_MPolyFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a MULTIPOLYGON</p></dd><dt><span class="term">ST_GeomCollFromText(text,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKT with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p><p>Throws an error if the WKT is not a GEOMETRYCOLLECTION</p></dd><dt><span class="term">ST_GeomFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.6.2 - option SRID is from the conformance
              suite</p></dd><dt><span class="term">ST_GeometryFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p></dd><dt><span class="term">ST_PointFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a POINT</p></dd><dt><span class="term">ST_LineFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a LINESTRING</p></dd><dt><span class="term">ST_LinestringFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>from the conformance suite</p><p>throws an error if WKB is not a LINESTRING</p></dd><dt><span class="term">ST_PolyFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a POLYGON</p></dd><dt><span class="term">ST_PolygonFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>from the conformance suite</p><p>throws an error if WKB is not a POLYGON</p></dd><dt><span class="term">ST_MPointFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a MULTIPOINT</p></dd><dt><span class="term">ST_MLineFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a MULTILINESTRING</p></dd><dt><span class="term">ST_MPolyFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a MULTIPOLYGON</p></dd><dt><span class="term">ST_GeomCollFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>Makes a Geometry from WKB with the given SRID. If SRID is
              not give, it defaults to -1.</p><p>OGC SPEC 3.2.7.2 - option SRID is from the conformance
              suite</p><p>throws an error if WKB is not a GEOMETRYCOLLECTION</p></dd><dt><a name="BdPolyFromText"></a><span class="term">ST_BdPolyFromText(text WKT, integer SRID)</span></dt><dd><p>Construct a Polygon given an arbitrary collection of
              closed linestrings as a MultiLineString text representation.</p><p>Throws an error if WKT is not a MULTILINESTRING. Throws an
              error if output is a MULTIPOLYGON; use <a class="link" href="#BdMPolyFromText">BdMPolyFromText</a> in that case,
              or see <a class="link" href="#BuildArea">BuildArea()</a> for a
              postgis-specific approach.</p><p>OGC SFSQL 1.1 - 3.2.6.2</p><p>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</p></dd><dt><a name="BdMPolyFromText"></a><span class="term">ST_BdMPolyFromText(text WKT, integer SRID)</span></dt><dd><p>Construct a MultiPolygon given an arbitrary collection of
              closed linestrings as a MultiLineString text representation.</p><p>Throws an error if WKT is not a MULTILINESTRING. Forces
              MULTIPOLYGON output even when result is really only composed by
              a single POLYGON; use <a class="link" href="#BdPolyFromText">BdPolyFromText</a>
              if you're sure a single POLYGON will result from operation,
              or see <a class="link" href="#BuildArea">BuildArea()</a> for a
              postgis-specific approach.</p><p>OGC SFSQL 1.1 - 3.2.6.2</p><p>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id307799"></a>6.2. PostGIS Extensions</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id307804"></a>6.2.1. Management Functions</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">DropGeometryTable([&lt;schema_name&gt;],
            &lt;table_name&gt;)</span></dt><dd><p>Drops a table and all its references in geometry_columns.
              Note: uses current_schema() on schema-aware pgsql installations
              if schema is not provided.</p></dd><dt><span class="term">UpdateGeometrySRID([&lt;schema_name&gt;],
            &lt;table_name&gt;, &lt;column_name&gt;, &lt;srid&gt;)</span></dt><dd><p>Update the SRID of all features in a geometry column
              updating constraints and reference in geometry_columns. Note:
              uses current_schema() on schema-aware pgsql installations if
              schema is not provided.</p></dd><dt><span class="term">update_geometry_stats([&lt;table_name&gt;,
            &lt;column_name&gt;])</span></dt><dd><p>Update statistics about spatial tables for use by the
              query planner. You will also need to run "VACUUM ANALYZE
              [table_name] [column_name]" for the statistics gathering
              process to be complete. NOTE: starting with PostgreSQL 8.0
              statistics gathering is automatically performed running
              "VACUUM ANALYZE".</p></dd><dt><span class="term">postgis_version()</span></dt><dd><p>Returns PostGIS version number and compile-time options</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Prior to version 1.1.0 this was a procedural function,
                thus possibly returning inaccurate information (in case of
                incomplete database upgrades).</p></div></dd><dt><a name="postgis_lib_version"></a><span class="term">postgis_lib_version()</span></dt><dd><p>Returns the version number of the PostGIS library.</p><p>Availability: 0.9.0</p></dd><dt><span class="term">postgis_lib_build_date()</span></dt><dd><p>Returns build date of the PostGIS library.</p><p>Availability: 1.0.0RC1</p></dd><dt><span class="term">postgis_script_build_date()</span></dt><dd><p>Returns build date of the PostGIS scripts.</p><p>Availability: 1.0.0RC1</p></dd><dt><span class="term">postgis_scripts_installed()</span></dt><dd><p>Returns version of the postgis scripts installed in this
              database.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the output of this function doesn't match the
                output of <a class="link" href="#postgis_scripts_released">postgis_scripts_released()</a>
                you probably missed to properly upgrade an existing database.
                See the <a class="link" href="#upgrading" title="2.2.2. Upgrading">Upgrading</a> section for
                more info.</p></div><p>Availability: 0.9.0</p></dd><dt><a name="postgis_scripts_released"></a><span class="term">postgis_scripts_released()</span></dt><dd><p>Returns the version number of the lwpostgis.sql script
              released with the installed postgis lib.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Starting with version 1.1.0 this function returns the
                same value of <a class="link" href="#postgis_lib_version">postgis_lib_version()</a>.
                Kept for backward compatibility.</p></div><p>Availability: 0.9.0</p></dd><dt><span class="term">postgis_geos_version()</span></dt><dd><p>Returns the version number of the GEOS library, or NULL if
              GEOS support is not enabled.</p><p>Availability: 0.9.0</p></dd><dt><span class="term">postgis_jts_version()</span></dt><dd><p>Returns the version number of the JTS library, or NULL if
              JTS support is not enabled.</p><p>Availability: 1.1.0</p></dd><dt><span class="term">postgis_proj_version()</span></dt><dd><p>Returns the version number of the PROJ4 library, or NULL
              if PROJ4 support is not enabled.</p><p>Availability: 0.9.0</p></dd><dt><span class="term">postgis_uses_stats()</span></dt><dd><p>Returns true if STATS usage has been enabled, false
              otherwise.</p><p>Availability: 0.9.0</p></dd><dt><a name="postgis_full_version"></a><span class="term">postgis_full_version()</span></dt><dd><p>Reports full postgis version and build configuration
              infos.</p><p>Availability: 0.9.0</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id308090"></a>6.2.2. Operators</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">A &amp;&lt; B</span></dt><dd><p>The "&amp;&lt;" operator returns true if A's
              bounding box overlaps or is to the left of B's bounding box.</p></dd><dt><span class="term">A &amp;&gt; B</span></dt><dd><p>The "&amp;&gt;" operator returns true if A's
              bounding box overlaps or is to the right of B's bounding
              box.</p></dd><dt><span class="term">A &lt;&lt; B</span></dt><dd><p>The "&lt;&lt;" operator returns true if A's
              bounding box is strictly to the left of B's bounding box.</p></dd><dt><span class="term">A &gt;&gt; B</span></dt><dd><p>The "&gt;&gt;" operator returns true if A's
              bounding box is strictly to the right of B's bounding box.</p></dd><dt><span class="term">A &amp;&lt;| B</span></dt><dd><p>The "&amp;&lt;|" operator returns true if A's
              bounding box overlaps or is below B's bounding box.</p></dd><dt><span class="term">A |&amp;&gt; B</span></dt><dd><p>The "|&amp;&gt;" operator returns true if A's
              bounding box overlaps or is above B's bounding box.</p></dd><dt><span class="term">A &lt;&lt;| B</span></dt><dd><p>The "&lt;&lt;|" operator returns true if A's
              bounding box is strictly below B's bounding box.</p></dd><dt><span class="term">A |&gt;&gt; B</span></dt><dd><p>The "|&gt;&gt;" operator returns true if A's
              bounding box is strictly above B's bounding box.</p></dd><dt><span class="term">A ~= B</span></dt><dd><p>The "~=" operator is the "same as"
              operator. It tests actual geometric equality of two features. So
              if A and B are the same feature, vertex-by-vertex, the operator
              returns true.</p></dd><dt><span class="term">A @ B</span></dt><dd><p>The "@" operator returns true if A's bounding
              box is completely contained by B's bounding box.</p></dd><dt><span class="term">A ~ B</span></dt><dd><p>The "~" operator returns true if A's bounding
              box completely contains B's bounding box.</p></dd><dt><span class="term">A &amp;&amp; B</span></dt><dd><p>The "&amp;&amp;" operator is the
              "overlaps" operator. If A's bounding box overlaps
              B's bounding box the operator returns true.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id308280"></a>6.2.3. Measurement Functions</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_area2d(geometry)</span></dt><dd><p>Returns the area of the geometry if it is a polygon or
              multi-polygon.</p></dd><dt><span class="term">ST_distance_sphere(point, point)</span></dt><dd><p>Returns linear distance in meters between two lat/lon
              points. Uses a spherical earth and radius of 6370986 meters.
              Faster than <a class="link" href="#distance_spheroid">distance_spheroid()</a>,
              but less accurate. Only implemented for points.</p></dd><dt><a name="distance_spheroid"></a><span class="term">ST_distance_spheroid(point, point, spheroid)</span></dt><dd><p>Returns linear distance between two lat/lon points given a
              particular spheroid. See the explanation of spheroids given for
              <a class="link" href="#length_spheroid">length_spheroid()</a>.
              Currently only implemented for points.</p></dd><dt><a name="length2d"></a><span class="term">ST_length2d(geometry)</span></dt><dd><p>Returns the 2-dimensional length of the geometry if it is
              a linestring or multi-linestring.</p></dd><dt><span class="term">ST_length3d(geometry)</span></dt><dd><p>Returns the 3-dimensional length of the geometry if it is
              a linestring or multi-linestring.</p></dd><dt><a name="length_spheroid"></a><span class="term">ST_length_spheroid(geometry,spheroid)</span></dt><dd><p>Calculates the length of of a geometry on an ellipsoid.
              This is useful if the coordinates of the geometry are in
              latitude/longitude and a length is desired without reprojection.
              The ellipsoid is a separate database type and can be constructed
              as follows:</p><div class="literallayout"><p>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR<br>
              AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</p></div><p>Eg:</p><div class="literallayout"><p>SPHEROID["GRS_1980",6378137,298.257222101]</p></div><p>An example calculation might look like this:</p><div class="literallayout"><p>SELECT length_spheroid( geometry_column,<br>
              'SPHEROID["GRS_1980",6378137,298.257222101]' )<br>
              FROM geometry_table;</p></div></dd><dt><span class="term">ST_length3d_spheroid(geometry,spheroid)</span></dt><dd><p>Calculates the length of of a geometry on an ellipsoid,
              taking the elevation into account. This is just like
              length_spheroid except vertical coordinates (expressed in the
              same units as the spheroid axes) are used to calculate the extra
              distance vertical displacement adds.</p></dd><dt><span class="term">ST_distance(geometry, geometry)</span></dt><dd><p>Returns the smaller distance between two geometries.</p></dd><dt><span class="term">ST_max_distance(linestring,linestring)</span></dt><dd><p>Returns the largest distance between two line strings.</p></dd><dt><span class="term">ST_perimeter(geometry)</span></dt><dd><p>Returns the 2-dimensional perimeter of the geometry, if it
              is a polygon or multi-polygon.</p></dd><dt><span class="term">ST_perimeter2d(geometry)</span></dt><dd><p>Returns the 2-dimensional perimeter of the geometry, if it
              is a polygon or multi-polygon.</p></dd><dt><span class="term">ST_perimeter3d(geometry)</span></dt><dd><p>Returns the 3-dimensional perimeter of the geometry, if it
              is a polygon or multi-polygon.</p></dd><dt><span class="term">ST_azimuth(geometry, geometry)</span></dt><dd><p>Returns the azimuth of the segment defined by the given
              Point geometries, or NULL if the two points are coincident.
              Return value is in radians.</p><p>Availability: 1.1.0</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id308525"></a>6.2.4. Geometry Outputs</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_AsBinary(geometry,{'NDR'|'XDR'})</span></dt><dd><p>Returns the geometry in the OGC
              "well-known-binary" format as a bytea, using
              little-endian (NDR) or big-endian (XDR) encoding. This is useful
              in binary cursors to pull data out of the database without
              converting it to a string representation.</p></dd><dt><span class="term">ST_AsEWKT(geometry)</span></dt><dd><p>Returns a Geometry in EWKT format (as text).</p></dd><dt><span class="term">ST_AsEWKB(geometry, {'NDR'|'XDR'})</span></dt><dd><p>Returns a Geometry in EWKB format (as bytea) using either
              little-endian (NDR) or big-endian (XDR) encoding.</p></dd><dt><span class="term">ST_AsHEXEWKB(geometry, {'NDR'|'XDR'})</span></dt><dd><p>Returns a Geometry in HEXEWKB format (as text) using
              either little-endian (NDR) or big-endian (XDR) encoding.</p></dd><dt><span class="term">ST_AsSVG(geometry, [rel], [precision])</span></dt><dd><p>Return the geometry as SVG path data. Use 1 as second argument to have the 
              path data implemented in terms of relative moves, the default (or 0) uses 
              absolute moves. Third argument may be used to reduce the maximum number of 
              decimal digits used in output (defaults to 15). Point geometries will be 
              rendered as cx/cy when 'rel' arg is 0, x/y when 'rel' is 1. Multipoint 
              geometries are delimited by commas (","), GeometryCollection geometries are 
              delimited by semicolons (";").</p></dd><dt><span class="term">ST_AsGML([version], geometry, [precision])</span></dt><dd><p>Return the geometry as a GML element. The version parameter,
              if specified, may be either 2 or 3. If no version parameter is
	      specified then the default is assumed to be 2. The third argument may
              be used to reduce the maximum number of significant digits used
              in output (defaults to 15).</p></dd><dt><span class="term">ST_AsKML(geometry, [precision])</span></dt><dd><p>Return the geometry as a KML element. Second argument may
              be used to reduce the maximum number of significant digits used
              in output (defaults to 15).</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id308642"></a>6.2.5. Geometry Constructors</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_GeomFromEWKT(text)</span></dt><dd><p>Makes a Geometry from EWKT.</p></dd><dt><span class="term">ST_GeomFromEWKB(bytea)</span></dt><dd><p>Makes a Geometry from EWKB.</p></dd><dt><span class="term">ST_MakePoint(&lt;x&gt;, &lt;y&gt;, [&lt;z&gt;],
            [&lt;m&gt;])</span></dt><dd><p>Creates a 2d,3dz or 4d point geometry.</p></dd><dt><span class="term">ST_MakePointM(&lt;x&gt;, &lt;y&gt;, &lt;m&gt;)</span></dt><dd><p>Creates a 3dm point geometry.</p></dd><dt><span class="term">ST_MakeBox2D(&lt;LL&gt;, &lt;UR&gt;)</span></dt><dd><p>Creates a BOX2D defined by the given point geometries.</p></dd><dt><span class="term">ST_MakeBox3D(&lt;LLB&gt;, &lt;URT&gt;)</span></dt><dd><p>Creates a BOX3D defined by the given point geometries.</p></dd><dt><span class="term">ST_MakeLine(geometry set)</span></dt><dd><p>Creates a Linestring from a set of point geometries. You
              might want to use a subselect to order points before feeding
              them to this aggregate.</p></dd><dt><span class="term">ST_MakeLine(geometry, geometry)</span></dt><dd><p>Creates a Linestring from the two given point geometries.</p></dd><dt><span class="term">ST_LineFromMultiPoint(multipoint)</span></dt><dd><p>Creates a LineString from a MultiPoint geometry.</p></dd><dt><span class="term">ST_MakePolygon(linestring, [linestring[]])</span></dt><dd><p>Creates a Polygon formed by the given shell and array of
              holes. You can construct a geometry array using <a class="link" href="#Accum">Accum</a>. Input geometries must be closed
              LINESTRINGS (see <a class="link" href="#IsClosed">IsClosed</a> and
              <a class="link" href="#GeometryType">GeometryType</a>).</p></dd><dt><a name="BuildArea"></a><span class="term">ST_BuildArea(geometry)</span></dt><dd><p>Creates an areal geometry formed by the constituent
              linework of given geometry. The return type can be a Polygon or
              MultiPolygon, depending on input. If the input lineworks do not
              form polygons NULL is returned.</p><p>See also <a class="link" href="#BdPolyFromText">BdPolyFromText</a>
              and <a class="link" href="#BdMPolyFromText">BdMPolyFromText</a> -
              wrappers to this function with standard OGC interface.</p><p>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</p></dd><dt><span class="term">ST_Polygonize(geometry set)</span></dt><dd><p>Aggregate. Creates a GeometryCollection containing
              possible polygons formed from the constituent linework of a set
              of geometries.</p><p>Availability: 1.0.0RC1 - requires GEOS &gt;= 2.1.0.</p></dd><dt><span class="term">ST_Collect(geometry set)</span></dt><dd><p>This function returns a GEOMETRYCOLLECTION or a MULTI
              object from a set of geometries. The collect() function is an
              "aggregate" function in the terminology of PostgreSQL.
              That means that it operators on lists of data, in the same way
              the sum() and mean() functions do. For example, "SELECT
              COLLECT(GEOM) FROM GEOMTABLE GROUP BY ATTRCOLUMN" will
              return a separate GEOMETRYCOLLECTION for each distinct value of
              ATTRCOLUMN.</p></dd><dt><span class="term">ST_Collect(geometry, geometry)</span></dt><dd><p>This function returns a geometry being a collection of two
              input geometries. Output type can be a MULTI* or a
              GEOMETRYCOLLECTION.</p></dd><dt><span class="term">ST_Dump(geometry)</span></dt><dd><p>This is a set-returning function (SRF). It returns a set
              of geometry_dump rows, formed by a geometry (geom) and an array
              of integers (path). When the input geometry is a simple type
              (POINT,LINESTRING,POLYGON) a single record will be returned with
              an empty path array and the input geometry as geom. When the
              input geometry is a collection or multi it will return a record
              for each of the collection components, and the path will express
              the position of the component inside the collection.</p><p>Availability: PostGIS 1.0.0RC1. Requires PostgreSQL 7.3 or
              higher.</p></dd><dt><span class="term">ST_DumpRings(geometry)</span></dt><dd><p>This is a set-returning function (SRF). It returns a set
              of geometry_dump rows, formed by a geometry (geom) and an array
              of integers (path). The 'path' field holds the polygon
              ring index, contains a single element: 0 for the shell, hole
              number for holes. The 'geom' field contains the
              corresponding ring as a polygon.</p><p>Availability: PostGIS 1.1.3. Requires PostgreSQL 7.3 or
              higher.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id258133"></a>6.2.6. Geometry Editors</h3></div></div></div><div class="variablelist"><dl><dt><a name="addbbox"></a><span class="term">ST_AddBBOX(geometry)</span></dt><dd><p>Add bounding box to the geometry. This would make bounding
              box based queries faster, but will increase the size of the
              geometry.</p></dd><dt><a name="dropbbox"></a><span class="term">ST_DropBBOX(geometry)</span></dt><dd><p>Drop the bounding box cache from the geometry. This
              reduces geometry size, but makes bounding-box based queries
              slower.</p></dd><dt><span class="term">ST_AddPoint(linestring, point, [&lt;position&gt;])</span></dt><dd><p>Adds a point to a LineString before point &lt;pos&gt;
              (0-based index). Third parameter can be omitted or set to -1 for
              appending.</p></dd><dt><span class="term">ST_RemovePoint(linestring, offset)</span></dt><dd><p>Removes point from a linestring. Offset is 0-based.</p><p>Availability: 1.1.0</p></dd><dt><span class="term">ST_SetPoint(linestring, N, point)</span></dt><dd><p>Replace point N of linestring with given point. Index is
              0-based.</p><p>Availability: 1.1.0</p></dd><dt><span class="term">ST_Force_collection(geometry)</span></dt><dd><p>Converts the geometry into a GEOMETRYCOLLECTION. This is
              useful for simplifying the WKB representation.</p></dd><dt><a name="force_2d"></a><span class="term">ST_Force_2d(geometry)</span></dt><dd><p>Forces the geometries into a "2-dimensional mode"
              so that all output representations will only have the X and Y
              coordinates. This is useful for force OGC-compliant output
              (since OGC only specifies 2-D geometries).</p></dd><dt><a name="force_3dz"></a><span class="term">ST_Force_3dz(geometry), </span><span class="term">ST_Force_3d(geometry)</span></dt><dd><p>Forces the geometries into XYZ mode.</p></dd><dt><a name="force_3dm"></a><span class="term">ST_Force_3dm(geometry)</span></dt><dd><p>Forces the geometries into XYM mode.</p></dd><dt><a name="force_4d"></a><span class="term">ST_Force_4d(geometry)</span></dt><dd><p>Forces the geometries into XYZM mode.</p></dd><dt><span class="term">ST_Multi(geometry)</span></dt><dd><p>Returns the geometry as a MULTI* geometry. If the geometry
              is already a MULTI*, it is returned unchanged.</p></dd><dt><span class="term">ST_Transform(geometry,integer)</span></dt><dd><p>Returns a new geometry with its coordinates transformed to
              the SRID referenced by the integer parameter. The destination
              SRID must exist in the <code class="varname">SPATIAL_REF_SYS</code> table.</p></dd><dt><span class="term">ST_Affine(geometry, float8, float8, float8, float8, float8,
            float8, float8, float8, float8, float8, float8, float8)</span></dt><dd><p>Applies an 3d affine transformation to the geometry. The
              call </p><pre class="programlisting">Affine(geom, a, b, c, d, e, f, g, h, i, xoff, yoff, zoff) </pre><p>               represents the transformation matrix 
              </p><pre class="programlisting">/ a  b  c  xoff \ 
| d  e  f  yoff | 
| g  h  i  zoff | 
\ 0  0  0     1 /</pre><p> and the
              vertices are transformed as follows:
              </p><pre class="programlisting">x' = a*x + b*y + c*z + xoff 
y' = d*x + e*y + f*z + yoff 
z' = g*x + h*y + i*z + zoff</pre><p> All of the translate / scale functions below
              are expressed via such an affine transformation.</p><p>Availability: 1.1.2.</p></dd><dt><span class="term">ST_Affine(geometry, float8, float8, float8, float8, float8,
            float8)</span></dt><dd><p>Applies an 2d affine transformation to the geometry. The
              call </p><pre class="programlisting">Affine(geom, a, b, d, e, xoff, yoff)</pre><p> represents the transformation matrix
              </p><pre class="programlisting">/  a  b  0  xoff  \       /  a  b  xoff  \ 
|  d  e  0  yoff  | rsp.  |  d  e  yoff  | 
|  0  0  1     0  |       \  0  0     1  / 
\  0  0  0     1  /</pre><p>
              and the vertices are transformed as follows:
              </p><pre class="programlisting">x' = a*x + b*y + xoff 
y' = d*x + e*y + yoff 
z' = z </pre><p> This method is a subcase of
              the 3D method above.</p><p>Availability: 1.1.2.</p></dd><dt><span class="term">ST_Translate(geometry, float8, float8, float8)</span></dt><dd><p>Translates the geometry to a new location using the
              numeric parameters as offsets. Ie: translate(geom, X, Y, Z).</p></dd><dt><span class="term">ST_Scale(geometry, float8, float8, float8)</span></dt><dd><p>scales the geometry to a new size by multiplying the
              ordinates with the parameters. Ie: scale(geom, Xfactor, Yfactor,
              Zfactor).</p><p>Availability: 1.1.0</p></dd><dt><a name="Rotate"></a><span class="term">ST_RotateZ(geometry, float8), </span><span class="term">ST_RotateX(geometry, float8), </span><span class="term">ST_RotateY(geometry, float8)</span></dt><dd><p>Rotate the geometry around the Z, X or Y axis by the given
              angle given in radians. Follows the right-hand rule.</p><p>Availability: 1.1.2.</p></dd><dt><span class="term">ST_TransScale(geometry, float8, float8, float8, float8)</span></dt><dd><p>First, translates the geometry using the first two floats,
              then scales it using the second two floats, working in 2D only.
              Using <code class="code">transscale(geom, X, Y, XFactor, YFactor)</code>
              internally calls <code class="code">affine(geom, XFactor, 0, 0, 0, YFactor,
              0, 0, 0, 1, X*XFactor, Y*YFactor, 0)</code>.</p><p>Availability: 1.1.0.</p></dd><dt><span class="term">ST_Reverse(geometry)</span></dt><dd><p>Returns the geometry with vertex order reversed.</p></dd><dt><span class="term">ST_ForceRHR(geometry)</span></dt><dd><p>Force polygons of the collection to obey Right-Hand-Rule.</p></dd><dt><span class="term">ST_Simplify(geometry, tolerance)</span></dt><dd><p>Returns a "simplified" version of the given
              geometry using the Douglas-Peuker algorithm. Will actually do
              something only with (multi)lines and (multi)polygons but you can
              safely call it with any kind of geometry. Since simplification
              occurs on a object-by-object basis you can also feed a
              GeometryCollection to this function. Note that returned geometry
              might loose its simplicity (see <a class="link" href="#IsSimple">IsSimple</a>)</p></dd><dt><span class="term">ST_SimplifyPreserveTopology(geometry, tolerance)</span></dt><dd><p>Returns a "simplified" version of the given
              geometry using the Douglas-Peuker algorithm. Will avoid 
              creating derived geometries (polygons in particular) that
              are invalid.</p></dd><dt><span class="term">ST_SnapToGrid(geometry, originX, originY, sizeX, sizeY), </span><span class="term">ST_SnapToGrid(geometry, sizeX, sizeY), </span><span class="term">ST_SnapToGrid(geometry, size)</span></dt><dd><p>Snap all points of the input geometry to the grid defined
              by its origin and cell size. Remove consecutive points falling
              on the same cell, eventually returning NULL if output points are
              not enough to define a geometry of the given type. Collapsed
              geometries in a collection are stripped from it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The returned geometry might loose its simplicity (see
                <a class="link" href="#IsSimple">IsSimple</a>).</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Before release 1.1.0 this function always returned a 2d
                geometry. Starting at 1.1.0 the returned geometry will have
                same dimensionality as the input one with higher dimension
                values untouched. Use the version taking a second geometry
                argument to define all grid dimensions.</p></div><p>Availability: 1.0.0RC1</p></dd><dt><span class="term">ST_SnapToGrid(geometry, geometry, sizeX, sizeY, sizeZ,
            sizeM)</span></dt><dd><p>Snap all points of the input geometry to the grid defined
              by its origin (the second argument, must be a point) and cell
              sizes. Specify 0 as size for any dimension you don't want to
              snap to a grid.</p><p>Availability: 1.1.0</p></dd><dt><span class="term">ST_Segmentize(geometry, maxlength)</span></dt><dd><p>Return a modified geometry having no segment longer then
              the given distance. Interpolated points will have Z and M values
              (if needed) set to 0. Distance computation is performed in 2d
              only.</p></dd><dt><span class="term">ST_LineMerge(geometry)</span></dt><dd><p>Returns a (set of) LineString(s) formed by sewing together
              constituent linework of input.</p><p>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id309528"></a>6.2.7. Linear Referencing</h3></div></div></div><div class="variablelist"><dl><dt><a name="line_interpolate_point"></a><span class="term">ST_line_interpolate_point(linestring, location)</span></dt><dd><p>Returns a point interpolated along a line. First argument
              must be a LINESTRING. Second argument is a float8 between 0 and
              1 representing fraction of total <a class="link" href="#length2d">2d
              length</a> the point has to be located.</p><p>See <a class="link" href="#line_locate_point">line_locate_point()</a>
              for computing the line location nearest to a Point.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Since release 1.1.1 this function also interpolates M
                and Z values (when present), while prior releases set them to
                0.0.</p></div><p>Availability: 0.8.2</p></dd><dt><a name="line_substring"></a><span class="term">ST_line_substring(linestring, start, end)</span></dt><dd><p>Return a linestring being a substring of the input one
              starting and ending at the given fractions of total 2d length.
              Second and third arguments are float8 values between 0 and 1.</p><p>If 'start' and 'end' have the same value
              this is equivalent to <a class="link" href="#line_interpolate_point">line_interpolate_point()</a>.</p><p>See <a class="link" href="#line_locate_point">line_locate_point()</a>
              for computing the line location nearest to a Point.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Since release 1.1.1 this function also interpolates M
                and Z values (when present), while prior releases set them to
                unspecified values.</p></div><p>Availability: 1.1.0</p></dd><dt><a name="line_locate_point"></a><span class="term">ST_line_locate_point(LineString, Point)</span></dt><dd><p>Returns a float between 0 and 1 representing the location
              of the closest point on LineString to the given Point, as a
              fraction of total <a class="link" href="#length2d">2d line</a>
              length.</p><p>You can use the returned location to extract a Point (<a class="link" href="#line_interpolate_point">line_interpolate_point</a>)
              or a substring (<a class="link" href="#line_substring">line_substring</a>).</p><p>Availability: 1.1.0</p></dd><dt><span class="term">ST_locate_along_measure(geometry, float8)</span></dt><dd><p>Return a derived geometry collection value with elements
              that match the specified measure. Polygonal elements are not
              supported.</p><p>Semantic is specified by: ISO/IEC CD 13249-3:200x(E) -
              Text for Continuation CD Editing Meeting</p><p>Availability: 1.1.0</p></dd><dt><span class="term">ST_locate_between_measures(geometry, float8, float8)</span></dt><dd><p>Return a derived geometry collection value with elements
              that match the specified range of measures inclusively.
              Polygonal elements are not supported.</p><p>Semantic is specified by: ISO/IEC CD 13249-3:200x(E) -
              Text for Continuation CD Editing Meeting</p><p>Availability: 1.1.0</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id309708"></a>6.2.8. Misc</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">ST_Summary(geometry)</span></dt><dd><p>Returns a text summary of the contents of the geometry.</p></dd><dt><span class="term">ST_box2d(geometry)</span></dt><dd><p>Returns a BOX2D representing the maximum extents of the
              geometry.</p></dd><dt><span class="term">ST_box3d(geometry)</span></dt><dd><p>Returns a BOX3D representing the maximum extents of the
              geometry.</p></dd><dt><span class="term">ST_extent(geometry set)</span></dt><dd><p>The extent() function is an "aggregate" function
              in the terminology of PostgreSQL. That means that it operators
              on lists of data, in the same way the sum() and mean() functions
              do. For example, "SELECT EXTENT(GEOM) FROM GEOMTABLE"
              will return a BOX3D giving the maximum extend of all features in
              the table. Similarly, "SELECT EXTENT(GEOM) FROM GEOMTABLE
              GROUP BY CATEGORY" will return one extent result for each
              category.</p></dd><dt><a name="zmflag"></a><span class="term">ST_zmflag(geometry)</span></dt><dd><p>Returns ZM (dimension semantic) flag of the geometries as
              a small int. Values are: 0=2d, 1=3dm, 2=3dz, 3=4d.</p></dd><dt><a name="hasbbox"></a><span class="term">ST_HasBBOX(geometry)</span></dt><dd><p>Returns TRUE if the bbox of this geometry is cached, FALSE
              otherwise. Use <a class="link" href="#addbbox">addBBOX()</a> and
              <a class="link" href="#dropbbox">dropBBOX()</a> to control caching.</p></dd><dt><a name="ndims"></a><span class="term">ST_ndims(geometry)</span></dt><dd><p>Returns number of dimensions of the geometry as a small
              int. Values are: 2,3 or 4.</p></dd><dt><span class="term">ST_nrings(geometry)</span></dt><dd><p>If the geometry is a polygon or multi-polygon returns the
              number of rings.</p></dd><dt><span class="term">ST_npoints(geometry)</span></dt><dd><p>Returns the number of points in the geometry.</p></dd><dt><a name="IsValid"></a><span class="term">ST_isvalid(geometry)</span></dt><dd><p>returns true if this geometry is valid.</p></dd><dt><span class="term">ST_expand(geometry, float)</span></dt><dd><p>This function returns a bounding box expanded in all
              directions from the bounding box of the input geometry, by an
              amount specified in the second argument. Very useful for
              distance() queries, to add an index filter to the query.</p></dd><dt><span class="term">ST_estimated_extent([schema], table, geocolumn)</span></dt><dd><p>Return the 'estimated' extent of the given spatial
              table. The estimated is taken from the geometry column's
              statistics. The current schema will be used if not specified.</p><p>For PostgreSQL&gt;=8.0.0 statistics are gathered by
              VACUUM ANALYZE and resulting extent will be about 95% of the
              real one.</p><p>For PostgreSQL&lt;8.0.0 statistics are gathered by
              update_geometry_stats() and resulting extent will be exact.</p></dd><dt><span class="term">ST_find_srid(varchar,varchar,varchar)</span></dt><dd><p>The syntax is find_srid(&lt;db/schema&gt;,
              &lt;table&gt;, &lt;column&gt;) and the function returns the
              integer SRID of the specified column by searching through the
              GEOMETRY_COLUMNS table. If the geometry column has not been
              properly added with the AddGeometryColumns() function, this
              function will not work either.</p></dd><dt><span class="term">ST_mem_size(geometry)</span></dt><dd><p>Returns the amount of space (in bytes) the geometry takes.</p></dd><dt><span class="term">ST_point_inside_circle(geometry, float, float, float)</span></dt><dd><p>The syntax for this functions is
              point_inside_circle(&lt;geometry&gt;,&lt;circle_center_x&gt;,&lt;circle_center_y&gt;,&lt;radius&gt;).
              Returns the true if the geometry is a point and is inside the
              circle. Returns false otherwise.</p></dd><dt><span class="term">ST_XMin(box3d) ST_YMin(box3d) ST_ZMin(box3d)</span></dt><dd><p>Returns the requested minima of a bounding box.</p></dd><dt><span class="term">ST_XMax(box3d) ST_YMax(box3d) ST_ZMax(box3d)</span></dt><dd><p>Returns the requested maxima of a bounding box.</p></dd><dt><a name="Accum"></a><span class="term">ST_Accum(geometry set)</span></dt><dd><p>Aggregate. Constructs an array of geometries.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id310341"></a>6.2.9. Long Transactions support</h3></div></div></div><p>
This module and associated pl/pgsql functions have been implemented
to provide long locking support required by
<a class="ulink" href="https://portal.opengeospatial.org/files/?artifact_id=7176" target="_top">Web Feature Service</a> specification.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
  Users must use <a class="ulink" href="http://www.postgresql.org/docs/7.4/static/transaction-iso.html" target="_top">serializable transaction level</a> otherwise locking mechanism would break.
	  </p></div><div class="variablelist"><dl><dt><a name="EnableLongTransactions"></a><span class="term">EnableLongTransactions()</span></dt><dd><p>
		Enable long transaction support. This function creates the
		required metadata tables, needs to be called once before
		using the other functions in this section. Calling it twice
		is harmless.
	    </p><p>
		    Availability: 1.1.3
		</p></dd><dt><a name="DisableLongTransactions"></a><span class="term">DisableLongTransactions()</span></dt><dd><p>
		Disable long transaction support. This function removes the
		long transaction support metadata tables, and drops all
		triggers attached to lock-checked tables.
	    </p><p>
		    Availability: 1.1.3
		</p></dd><dt><a name="CheckAuth"></a><span class="term">CheckAuth([&lt;schema&gt;], &lt;table&gt;, &lt;rowid_col&gt;)</span></dt><dd><p>
		Check updates and deletes of rows in
		given table for being authorized.
		Identify rows using &lt;rowid_col&gt; column.
	    </p><p>
		    Availability: 1.1.3
		</p></dd><dt><a name="LockRow"></a><span class="term">LockRow([&lt;schema&gt;], &lt;table&gt;, &lt;rowid&gt;, &lt;authid&gt;, [&lt;expires&gt;])</span></dt><dd><p>
	Set lock/authorization for specific row in table
	&lt;authid&gt; is a text value, &lt;expires&gt; is a timestamp
	defaulting to now()+1hour.
	Returns 1 if lock has been assigned, 0 otherwise
	(already locked by other auth)
	    </p><p>
		    Availability: 1.1.3
		</p></dd><dt><a name="UnlockRows"></a><span class="term">UnlockRows(&lt;authid&gt;)</span></dt><dd><p>
	Remove all locks held by specified authorization id.
	Returns the number of locks released.
	    </p><p>
		    Availability: 1.1.3
		</p></dd><dt><a name="AddAuth"></a><span class="term">AddAuth(&lt;authid&gt;)</span></dt><dd><p>
	Add an authorization token to be used in current
	transaction. 
	    </p><p>
		    Availability: 1.1.3
		</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id310131"></a>6.3. SQL-MM Functions</h2></div></div></div><p>This is a listing of the SQL-MM defined functions that PostGIS
      currently supports. The implementations of these functions follow the
      ArcSDE implementation, and thus deviate somewhat from the spec. These
      deviations will be noted.</p><p>As of version 1.2.0, these functions have been implemented by
      wrapping existing PostGIS functions. As a result, full support for
      curved geometries may not be in place for many functions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the default SRID of all geometry constructors as
        0. PostGIS uses a default SRID of -1.</p></div><div class="variablelist"><dl><dt><span class="term">ST_Area</span></dt><dd><p>Return the area measurement of an ST_Surface or
            ST_MultiSurface value.</p><p>SQL-MM 3: 8.1.2, 9.5.3</p></dd><dt><span class="term">ST_AsBinary</span></dt><dd><p>Return the well-known binary representation of an
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.37</p></dd><dt><span class="term">ST_AsText</span></dt><dd><p>Return the well-known text representation of an ST_Geometry
            value.</p><p>SQL-MM 3: 5.1.25</p></dd><dt><span class="term">ST_Boundary</span></dt><dd><p>Return the boundary of the ST_Geometry value.</p><p>SQL-MM 3: 5.1.14</p></dd><dt><span class="term">ST_Buffer</span></dt><dd><p>Return a buffer around the ST_Geometry value.</p><p>SQL-MM 3: 5.1.17</p></dd><dt><span class="term">ST_Centroid</span></dt><dd><p>Return mathematical centroid of the ST_Surface or
            ST_MultiSurface value.</p><p>SQL-MM 3: 8.1.4, 9.5.5</p></dd><dt><span class="term">ST_Contains</span></dt><dd><p>Test if an ST_Geometry value spatially contains another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.31</p></dd><dt><span class="term">ST_ConvexHull</span></dt><dd><p>Return the convex hull of the ST_Geometry value.</p><p>SQL-MM 3: 5.1.16</p></dd><dt><span class="term">ST_CoordDim</span></dt><dd><p>Return the coordinate dimension of the ST_Geometry value.</p><p>SQL-MM 3: 5.1.3</p></dd><dt><span class="term">ST_Crosses</span></dt><dd><p>Test if an ST_Geometry value spatially crosses another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.29</p></dd><dt><span class="term">ST_Difference</span></dt><dd><p>Return an ST_Geometry value that represents the point set
            difference of two ST_Geometry values.</p><p>SQL-MM 3: 5.1.20</p></dd><dt><span class="term">ST_Dimension</span></dt><dd><p>Return the dimension of the ST_Geometry value.</p><p>SQL-MM 3: 5.1.2</p></dd><dt><span class="term">ST_Disjoint</span></dt><dd><p>Test if an ST_Geometry value is spatially disjoint from
            another ST_Geometry value.</p><p>SQL-MM 3: 5.1.26</p></dd><dt><span class="term">ST_Distance</span></dt><dd><p>Return the distance between two geometries.</p><p>SQL-MM 3: 5.1.23</p></dd><dt><span class="term">ST_EndPoint</span></dt><dd><p>Return an ST_Point value that is the end point of an
            ST_Curve value.</p><p>SQL-MM 3: 7.1.4</p></dd><dt><span class="term">ST_Envelope</span></dt><dd><p>Return the bounding rectangle for the ST_Geometry value.</p><p>SQL-MM 3: 5.1.15</p></dd><dt><span class="term">ST_Equals</span></dt><dd><p>Test if an ST_Geometry value as spatially equal to another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.24</p></dd><dt><span class="term">ST_ExteriorRing</span></dt><dd><p>Return the exterior ring of an ST_Surface</p><p>SQL-MM 3: 8.2.3, 8.3.3</p></dd><dt><span class="term">ST_GeometryN</span></dt><dd><p>Return the indicated ST_Geometry value from an
            ST_GeomCollection.</p><p>SQL-MM 3: 9.1.5</p></dd><dt><span class="term">ST_GeometryType</span></dt><dd><p>Return the geometry type of the ST_Geometry value.</p><p>SQL-MM 3: 5.1.4</p></dd><dt><span class="term">ST_GeomFromText</span></dt><dd><p>Return a specified ST_Geometry value.</p><p>SQL-MM 3: 5.1.40</p></dd><dt><span class="term">ST_GeomFromWKB</span></dt><dd><p>Return a specified ST_Geometry value.</p><p>SQL-MM 3: 5.1.41</p></dd><dt><span class="term">ST_InteriorRingN</span></dt><dd><p>Return the specified interior ring of an ST_Surface value.</p><p>SQL-MM 3: 8.2.6, 8.3.5</p></dd><dt><span class="term">ST_Intersection</span></dt><dd><p>Return an ST_Geometry value that represents the point set
            intersection of two ST_Geometry values.</p><p>SQL-MM 3: 5.1.18</p></dd><dt><span class="term">ST_Intersects</span></dt><dd><p>Test if an ST_Geometry value spatially intersects another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.27</p></dd><dt><span class="term">ST_IsClosed</span></dt><dd><p>Test if an ST_Curve or ST_MultiCurve value is closed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the result of ST_IsClosed(NULL) to be 0,
              while PostGIS returns NULL.</p></div><p>SQL-MM 3: 7.1.5, 9.3.3</p></dd><dt><span class="term">ST_IsEmpty</span></dt><dd><p>Test if an ST_Geometry value corresponds to the empty set.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the result of ST_IsEmpty(NULL) to be 0,
              while PostGIS returns NULL.</p></div><p>SQL-MM 3: 5.1.7</p></dd><dt><span class="term">ST_IsRing</span></dt><dd><p>Test if an ST_Curve value is a ring.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the result of ST_IsRing(NULL) to be 0,
              while PostGIS returns NULL.</p></div><p>SQL-MM 3: 7.1.6</p></dd><dt><span class="term">ST_IsSimple</span></dt><dd><p>Test if an ST_Geometry value has no anomalous geometric
            points, such as self intersection or self tangency.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the result of ST_IsSimple(NULL) to be 0,
              while PostGIS returns NULL.</p></div><p>SQL-MM 3: 5.1.8</p></dd><dt><span class="term">ST_IsValid</span></dt><dd><p>Test if an ST_Geometry value is well formed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>SQL-MM defines the result of ST_IsValid(NULL) to be 0,
              while PostGIS returns NULL.</p></div><p>SQL-MM defines the result of ST_IsValid(NULL) to be 1</p><p>SQL-MM 3: 5.1.9</p></dd><dt><span class="term">ST_Length</span></dt><dd><p>Return the length measurement of an ST_Curve or
            ST_MultiCurve value.</p><p>SQL-MM 3: 7.1.2, 9.3.4</p></dd><dt><span class="term">ST_LineFromText</span></dt><dd><p>Return a specified ST_LineString value.</p><p>SQL-MM 3: 7.2.8</p></dd><dt><span class="term">ST_LineFromWKB</span></dt><dd><p>Return a specified ST_LineString value.</p><p>SQL-MM 3: 7.2.9</p></dd><dt><span class="term">ST_MLineFromText</span></dt><dd><p>Return a specified ST_MultiLineString value.</p><p>SQL-MM 3: 9.4.4</p></dd><dt><span class="term">ST_MLineFromWKB</span></dt><dd><p>Return a specified ST_MultiLineString value.</p><p>SQL-MM 3: 9.4.5</p></dd><dt><span class="term">ST_MPointFromText</span></dt><dd><p>Return a specified ST_MultiPoint value.</p><p>SQL-MM 3: 9.2.4</p></dd><dt><span class="term">ST_MPointFromWKB</span></dt><dd><p>Return a specified ST_MultiPoint value.</p><p>SQL-MM 3: 9.2.5</p></dd><dt><span class="term">ST_MPolyFromText</span></dt><dd><p>Return a specified ST_MultiPolygon value.</p><p>SQL-MM 3: 9.6.4</p></dd><dt><span class="term">ST_MPolyFromWKB</span></dt><dd><p>Return a specified ST_MultiPolygon value.</p><p>SQL-MM 3: 9.6.5</p></dd><dt><span class="term">ST_NumGeometries</span></dt><dd><p>Return the number of geometries in an ST_GeomCollection.</p><p>SQL-MM 3: 9.1.4</p></dd><dt><span class="term">ST_NumInteriorRing</span></dt><dd><p>Return the number of interior rings in an ST_Surface.</p><p>SQL-MM 3: 8.2.5</p></dd><dt><span class="term">ST_NumPoints</span></dt><dd><p>Return the number of points in an ST_LineString or
            ST_CircularString value.</p><p>SQL-MM 3: 7.2.4</p></dd><dt><span class="term">ST_OrderingEquals</span></dt><dd><p>ST_OrderingEquals compares two geometries and t (TRUE) if
            the geometries are equal and the coordinates are in the same
            order; otherwise it returns f (FALSE).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function is implemented as per the ArcSDE SQL
              specification rather than SQL-MM.
              http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3.htm#ST_OrderingEquals</p></div><p>SQL-MM 3: 5.1.43</p></dd><dt><span class="term">ST_Overlaps</span></dt><dd><p>Test if an ST_Geometry value spatially overlays another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.32</p></dd><dt><span class="term">ST_Perimeter</span></dt><dd><p>Return the length measurement of the boundary of an
            ST_Surface or ST_MultiRSurface value.</p><p>SQL-MM 3: 8.1.3, 9.5.4</p></dd><dt><span class="term">ST_Point</span></dt><dd><p>Returns an ST_Point with the given coordinate values.</p><p>SQL-MM 3: 6.1.2</p></dd><dt><span class="term">ST_PointFromText</span></dt><dd><p>Return a specified ST_Point value.</p><p>SQL-MM 3: 6.1.8</p></dd><dt><span class="term">ST_PointFromWKB</span></dt><dd><p>Return a specified ST_Point value.</p><p>SQL-MM 3: 6.1.9</p></dd><dt><span class="term">ST_PointN</span></dt><dd><p>Return the specified ST_Point value in an ST_LineString or
            ST_CircularString</p><p>SQL-MM 3: 7.2.5, 7.3.5</p></dd><dt><span class="term">ST_PointOnSurface</span></dt><dd><p>Return an ST_Point value guaranteed to spatially intersect
            the ST_Surface or ST_MultiSurface value.</p><p>SQL-MM 3: 8.1.5, 9.5.6</p></dd><dt><span class="term">ST_PolyFromText</span></dt><dd><p>Return a specified ST_Polygon value.</p><p>SQL-MM 3: 8.3.6</p></dd><dt><span class="term">ST_PolyFromWKB</span></dt><dd><p>Return a specified ST_Polygon value.</p><p>SQL-MM 3: 8.3.7</p></dd><dt><span class="term">ST_Polygon</span></dt><dd><p>Return a polygon build from the specified linestring and
            SRID.</p><p>SQL-MM 3: 8.3.2</p></dd><dt><span class="term">ST_Relate</span></dt><dd><p>Test if an ST_Geometry value is spatially related to another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.25</p></dd><dt><span class="term">ST_SRID</span></dt><dd><p>Return the spatial reference system identifier of the
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.5</p></dd><dt><span class="term">ST_StartPoint</span></dt><dd><p>Return an ST_Point value that is the start point of an
            ST_Curve value.</p><p>SQL-MM 3: 7.1.3</p></dd><dt><span class="term">ST_SymDifference</span></dt><dd><p>Return an ST_Geometry value that represents the point set
            symmetric difference of two ST_Geometry values.</p><p>SQL-MM 3: 5.1.21</p></dd><dt><span class="term">ST_Touches</span></dt><dd><p>Test if an ST_Geometry value spatially touches another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.28</p></dd><dt><span class="term">ST_Transform</span></dt><dd><p>Return an ST_Geometry value transformed to the specified
            spatial reference system.</p><p>SQL-MM 3: 5.1.6</p></dd><dt><span class="term">ST_Union</span></dt><dd><p>Return an ST_Geometry value that represents the point set
            union of two ST_Geometry values.</p><p>SQL-MM 3: 5.1.19</p></dd><dt><span class="term">ST_Within</span></dt><dd><p>Test if an ST_Geometry value is spatially within another
            ST_Geometry value.</p><p>SQL-MM 3: 5.1.30</p></dd><dt><span class="term">ST_WKBToSQL</span></dt><dd><p>Return an ST_Geometry value for a given well-known binary
            representation.</p><p>SQL-MM 3: 5.1.36</p></dd><dt><span class="term">ST_WKTToSQL</span></dt><dd><p>Return an ST_Geometry value for a given well-known text
            representation.</p><p>SQL-MM 3: 5.1.34</p></dd><dt><span class="term">ST_X</span></dt><dd><p>Returns the x coordinate value of an ST_Point value.</p><p>SQL-MM 3: 6.1.3</p></dd><dt><span class="term">ST_Y</span></dt><dd><p>Returns the y coordinate value of an ST_Point value.</p><p>SQL-MM 3: 6.1.4</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id311488"></a>6.4. ArcSDE Functions</h2></div></div></div><p>Additional functions have been added to improve support for an
      ArcSDE style interface.</p><div class="variablelist"><dl><dt><span class="term">SE_EnvelopesIntersect</span></dt><dd><p>Returns t (TRUE) if the envelopes of two geometries
            intersect; otherwise, it returns f (FALSE).</p></dd><dt><span class="term">SE_Is3d</span></dt><dd><p>Test if a geometry value has z coordinate values.</p></dd><dt><span class="term">SE_IsMeasured</span></dt><dd><p>Test if a geometry value has m coordinate values.</p></dd><dt><span class="term">SE_LocateAlong</span></dt><dd><p>Return a derived geometry collection value with elements
            that match the specified measur.</p></dd><dt><span class="term">SE_LocateBetween</span></dt><dd><p>Return a derived geometry collection value with elements
            that match the specified range of measures inclusively.</p></dd><dt><span class="term">SE_M</span></dt><dd><p>Returns the m coordinate value of an ST_Point value.</p></dd><dt><span class="term">SE_Z</span></dt><dd><p>Returns the z coordinate value of an ST_Point value</p></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id311596"></a>Chapter 7. Reporting Bugs</h2></div></div></div><p>Reporting bugs effectively is a fundamental way to help PostGIS
    development. The most effective bug report is that enabling PostGIS
    developers to reproduce it, so it would ideally contain a script
    triggering it and every information regarding the environment in which it
    was detected. Good enough info can be extracted running <code class="code">SELECT
    postgis_full_version()</code> [for postgis] and <code class="code">SELECT version()</code>
    [for postgresql].</p><p>If you aren't using latest release, it's worth taking a look
    at its <a class="ulink" href="http://postgis.refractions.net/CHANGES.txt" target="_top">release
    changelog</a> first, to find out if your bug has already been fixed.</p><p>Using the <a class="ulink" href="http://code.google.com/p/postgis/issues/list" target="_top">PostGIS
    bug tracker</a> will ensure your reports are not discarded, and will
    keep you informed on it's handling process. Before reporting a new bug
    please query the database to see if it is a known one, and if it is please
    add any new information you have about it.</p><p>You might want to read Simon Tatham's paper about <a class="ulink" href="http://www.chiark.greenend.org.uk/~sgtatham/bugs.html" target="_top">How to Report
    Bugs Effectively</a> before filing a new report.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="release_notes"></a>Appendix A. Appendix</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id311650">A.1. Release Notes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id311656">A.1.1. Release 1.3.3</a></span></dt><dt><span class="sect2"><a href="#id311671">A.1.2. Release 1.3.2</a></span></dt><dt><span class="sect2"><a href="#id311685">A.1.3. Release 1.3.1</a></span></dt><dt><span class="sect2"><a href="#id311699">A.1.4. Release 1.3.0</a></span></dt><dt><span class="sect2"><a href="#id311765">A.1.5. Release 1.2.1</a></span></dt><dt><span class="sect2"><a href="#id311804">A.1.6. Release 1.2.0</a></span></dt><dt><span class="sect2"><a href="#id311833">A.1.7. Release 1.1.6</a></span></dt><dt><span class="sect2"><a href="#id311928">A.1.8. Release 1.1.5</a></span></dt><dt><span class="sect2"><a href="#id312022">A.1.9. Release 1.1.4</a></span></dt><dt><span class="sect2"><a href="#id312122">A.1.10. Release 1.1.3</a></span></dt><dt><span class="sect2"><a href="#id312260">A.1.11. Release 1.1.2</a></span></dt><dt><span class="sect2"><a href="#id312371">A.1.12. Release 1.1.1</a></span></dt><dt><span class="sect2"><a href="#id312477">A.1.13. Release 1.1.0</a></span></dt><dt><span class="sect2"><a href="#id312747">A.1.14. Release 1.0.6</a></span></dt><dt><span class="sect2"><a href="#id312836">A.1.15. Release 1.0.5</a></span></dt><dt><span class="sect2"><a href="#id312950">A.1.16. Release 1.0.4</a></span></dt><dt><span class="sect2"><a href="#rel_1.0.3_upgrading">A.1.17. Release 1.0.3</a></span></dt><dt><span class="sect2"><a href="#id313152">A.1.18. Release 1.0.2</a></span></dt><dt><span class="sect2"><a href="#id313220">A.1.19. Release 1.0.1</a></span></dt><dt><span class="sect2"><a href="#id313306">A.1.20. Release 1.0.0</a></span></dt><dt><span class="sect2"><a href="#id313391">A.1.21. Release 1.0.0RC6</a></span></dt><dt><span class="sect2"><a href="#id313456">A.1.22. Release 1.0.0RC5</a></span></dt><dt><span class="sect2"><a href="#id313518">A.1.23. Release 1.0.0RC4</a></span></dt><dt><span class="sect2"><a href="#id313625">A.1.24. Release 1.0.0RC3</a></span></dt><dt><span class="sect2"><a href="#id313774">A.1.25. Release 1.0.0RC2</a></span></dt><dt><span class="sect2"><a href="#id313859">A.1.26. Release 1.0.0RC1</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id311650"></a>A.1. Release Notes</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311656"></a>A.1.1. Release 1.3.3</h3></div></div></div><p>Release date: 2008/04/12</p><p>This release fixes bugs shp2pgsql, adds enhancements
        to SVG and KML support, adds a ST_SimplifyPreserveTopology
        function, makes the build more sensitive to GEOS versions,
        and fixes a handful of severe but rare failure cases.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311671"></a>A.1.2. Release 1.3.2</h3></div></div></div><p>Release date: 2007/12/01</p><p>This release fixes bugs in ST_EndPoint() and ST_Envelope,
        improves support for JDBC building and OS/X, and adds
        better support for GML output with ST_AsGML(), including
        GML3 output.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311685"></a>A.1.3. Release 1.3.1</h3></div></div></div><p>Release date: 2007/08/13</p><p>This release fixes some oversights in the previous release
        around version numbering, documentation, and tagging.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311699"></a>A.1.4. Release 1.3.0</h3></div></div></div><p>Release date: 2007/08/09</p><p>This release provides performance enhancements to the relational
        functions, adds new relational functions and begins the migration of
        our function names to the SQL-MM convension, using the spatial type 
        (SP) prefix.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311713"></a>A.1.4.1. Added Functionality</h4></div></div></div><p>JDBC: Added Hibernate Dialect (thanks to Norman Barker)</p><p>Added ST_Covers and ST_CoveredBy relational functions.  
          Description and justification of these functions can be found at
          http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html</p><p>Added ST_DWithin relational function.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311731"></a>A.1.4.2. Performance Enhancements</h4></div></div></div><p>Added cached and indexed point-in-polygon short-circuits
          for the functions ST_Contains, ST_Intersects, ST_Within and 
          ST_Disjoint</p><p>Added inline index support for relational functions
          (except ST_Disjoint)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311746"></a>A.1.4.3. Other Changes</h4></div></div></div><p>Extended curved geometry support into the geometry accessor 
          and some processing functions</p><p>Began migration of functions to the SQL-MM naming convension;
          using a spatial type (ST) prefix.</p><p>Added initial support for PostgreSQL 8.3</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311765"></a>A.1.5. Release 1.2.1</h3></div></div></div><p>Release date: 2007/01/11</p><p>This release provides bug fixes in PostgreSQL 8.2 support and
        some small performance enhancements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311778"></a>A.1.5.1. Changes</h4></div></div></div><p>Fixed point-in-polygon shortcut bug in Within().</p><p>Fixed PostgreSQL 8.2 NULL handling for indexes.</p><p>Updated RPM spec files.</p><p>Added short-circuit for Transform() in no-op case.</p><p>JDBC: Fixed JTS handling for multi-dimensional geometries
          (thanks to Thomas Marti for hint and partial patch). Additionally,
          now JavaDoc is compiled and packaged. Fixed classpath problems with
          GCJ. Fixed pgjdbc 8.2 compatibility, losing support for jdk 1.3 and
          older.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311804"></a>A.1.6. Release 1.2.0</h3></div></div></div><p>Release date: 2006/12/08</p><p>This release provides type definitions along with
        serialization/deserialization capabilities for SQL-MM defined curved
        geometries, as well as performance enhancements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311818"></a>A.1.6.1. Changes</h4></div></div></div><p>Added curved geometry type support for
          serialization/deserialization</p><p>Added point-in-polygon shortcircuit to the Contains and Within
          functions to improve performance for these cases.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311833"></a>A.1.7. Release 1.1.6</h3></div></div></div><p>Release date: 2006/11/02</p><p>This is a bugfix release, in particular fixing a critical error
        with GEOS interface in 64bit systems. Includes an updated of the SRS
        parameters and an improvement in reprojections (take Z in
        consideration). Upgrade is <span class="emphasis"><em>encouraged</em></span>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311850"></a>A.1.7.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311887"></a>A.1.7.2. Bug fixes</h4></div></div></div><p>fixed CAPI change that broke 64-bit platforms</p><p>loader/dumper: fixed regression tests and usage output</p><p>Fixed setSRID() bug in JDBC, thanks to Thomas Marti</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311903"></a>A.1.7.3. Other changes</h4></div></div></div><p>use Z ordinate in reprojections</p><p>spatial_ref_sys.sql updated to EPSG 6.11.1</p><p>Simplified Version.config infrastructure to use a single pack
          of version variables for everything.</p><p>Include the Version.config in loader/dumper USAGE messages</p><p>Replace hand-made, fragile JDBC version parser with Properties</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id311928"></a>A.1.8. Release 1.1.5</h3></div></div></div><p>Release date: 2006/10/13</p><p>This is an bugfix release, including a critical segfault on
        win32. Upgrade is <span class="emphasis"><em>encouraged</em></span>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311944"></a>A.1.8.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id311980"></a>A.1.8.2. Bug fixes</h4></div></div></div><p>Fixed MingW link error that was causing pgsql2shp to segfault
          on Win32 when compiled for PostgreSQL 8.2</p><p>fixed nullpointer Exception in Geometry.equals() method in
          Java</p><p>Added EJB3Spatial.odt to fulfill the GPL requirement of
          distributing the "preferred form of modification"</p><p>Removed obsolete synchronization from JDBC Jts code.</p><p>Updated heavily outdated README files for shp2pgsql/pgsql2shp
          by merging them with the manpages.</p><p>Fixed version tag in jdbc code that still said "1.1.3"
          in the "1.1.4" release.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312011"></a>A.1.8.3. New Features</h4></div></div></div><p>Added -S option for non-multi geometries to shp2pgsql</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312022"></a>A.1.9. Release 1.1.4</h3></div></div></div><p>Release date: 2006/09/27</p><p>This is an bugfix release including some improvements in the
        Java interface. Upgrade is <span class="emphasis"><em>encouraged</em></span>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312038"></a>A.1.9.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312074"></a>A.1.9.2. Bug fixes</h4></div></div></div><p>Fixed support for PostgreSQL 8.2</p><p>Fixed bug in collect() function discarding SRID of input</p><p>Added SRID match check in MakeBox2d and MakeBox3d</p><p>Fixed regress tests to pass with GEOS-3.0.0</p><p>Improved pgsql2shp run concurrency.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312097"></a>A.1.9.3. Java changes</h4></div></div></div><p>reworked JTS support to reflect new upstream JTS
          developers' attitude to SRID handling. Simplifies code and drops
          build depend on GNU trove.</p><p>Added EJB2 support generously donated by the "Geodetix
          s.r.l. Company" http://www.geodetix.it/</p><p>Added EJB3 tutorial / examples donated by Norman Barker
          &lt;nbarker@ittvis.com&gt;</p><p>Reorganized java directory layout a little.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312122"></a>A.1.10. Release 1.1.3</h3></div></div></div><p>Release date: 2006/06/30</p><p>This is an bugfix release including also some new
        functionalities (most notably long transaction support) and
        portability enhancements. Upgrade is <span class="emphasis"><em>encouraged</em></span>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312139"></a>A.1.10.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312175"></a>A.1.10.2. Bug fixes / correctness</h4></div></div></div><p>BUGFIX in distance(poly,poly) giving wrong results.</p><p>BUGFIX in pgsql2shp successful return code.</p><p>BUGFIX in shp2pgsql handling of MultiLine WKT.</p><p>BUGFIX in affine() failing to update bounding box.</p><p>WKT parser: forbidden construction of multigeometries with
          EMPTY elements (still supported for GEOMETRYCOLLECTION).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312198"></a>A.1.10.3. New functionalities</h4></div></div></div><p>NEW Long Transactions support.</p><p>NEW DumpRings() function.</p><p>NEW AsHEXEWKB(geom, XDR|NDR) function.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312214"></a>A.1.10.4. JDBC changes</h4></div></div></div><p>Improved regression tests: MultiPoint and scientific ordinates</p><p>Fixed some minor bugs in jdbc code</p><p>Added proper accessor functions for all fields in preparation
          of making those fields private later</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312232"></a>A.1.10.5. Other changes</h4></div></div></div><p>NEW regress test support for loader/dumper.</p><p>Added --with-proj-libdir and --with-geos-libdir configure
          switches.</p><p>Support for build Tru64 build.</p><p>Use Jade for generating documentation.</p><p>Don't link pgsql2shp to more libs then required.</p><p>Initial support for PostgreSQL 8.2.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312260"></a>A.1.11. Release 1.1.2</h3></div></div></div><p>Release date: 2006/03/30</p><p>This is an bugfix release including some new functions and
        portability enhancements. Upgrade is <span class="emphasis"><em>encouraged</em></span>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312276"></a>A.1.11.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312312"></a>A.1.11.2. Bug fixes</h4></div></div></div><p>BUGFIX in SnapToGrid() computation of output bounding box</p><p>BUGFIX in EnforceRHR()</p><p>jdbc2 SRID handling fixes in JTS code</p><p>Fixed support for 64bit archs</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312332"></a>A.1.11.3. New functionalities</h4></div></div></div><p>Regress tests can now be run *before* postgis installation</p><p>New affine() matrix transformation functions</p><p>New rotate{,X,Y,Z}() function</p><p>Old translating and scaling functions now use affine()
          internally</p><p>Embedded access control in estimated_extent() for builds
          against pgsql &gt;= 8.0.0</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312357"></a>A.1.11.4. Other changes</h4></div></div></div><p>More portable ./configure script</p><p>Changed ./run_test script to have more sane default behaviour</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312371"></a>A.1.12. Release 1.1.1</h3></div></div></div><p>Release date: 2006/01/23</p><p>This is an important Bugfix release, upgrade is
        <span class="emphasis"><em>highly recommended</em></span>. Previous version contained a
        bug in postgis_restore.pl preventing <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard
        upgrade</a> procedure to complete and a bug in GEOS-2.2+ connector
        preventing GeometryCollection objects to be used in topological
        operations.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312394"></a>A.1.12.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later follow the
          <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a> procedure.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312430"></a>A.1.12.2. Bug fixes</h4></div></div></div><p>Fixed a premature exit in postgis_restore.pl</p><p>BUGFIX in geometrycollection handling of GEOS-CAPI connector</p><p>Solaris 2.7 and MingW support improvements</p><p>BUGFIX in line_locate_point()</p><p>Fixed handling of postgresql paths</p><p>BUGFIX in line_substring()</p><p>Added support for localized cluster in regress tester</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312460"></a>A.1.12.3. New functionalities</h4></div></div></div><p>New Z and M interpolation in line_substring()</p><p>New Z and M interpolation in line_interpolate_point()</p><p>added NumInteriorRing() alias due to OpenGIS ambiguity</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312477"></a>A.1.13. Release 1.1.0</h3></div></div></div><p>Release date: 2005/12/21</p><p>This is a Minor release, containing many improvements and new
        things. Most notably: build procedure greatly simplified; transform()
        performance drastically improved; more stable GEOS connectivity (CAPI
        support); lots of new functions; draft topology support.</p><p>It is <span class="emphasis"><em>highly recommended</em></span> that you upgrade
        to GEOS-2.2.x before installing PostGIS, this will ensure future GEOS
        upgrades won't require a rebuild of the PostGIS library.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312499"></a>A.1.13.1. Credits</h4></div></div></div><p>This release includes code from Mark Cave Ayland for caching
          of proj4 objects. Markus Schaber added many improvements in his
          JDBC2 code. Alex Bodnaru helped with PostgreSQL source dependency
          relief and provided Debian specfiles. Michael Fuhr tested new things
          on Solaris arch. David Techer and Gerald Fenoy helped testing GEOS
          C-API connector. Hartmut Tschauner provided code for the azimuth()
          function. Devrim GUNDUZ provided RPM specfiles. Carl Anderson helped
          with the new area building functions. See the <a class="link" href="#credits" title="1.1. Credits">credits</a> section for more names.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312519"></a>A.1.13.2. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload. Simply sourcing the
          new lwpostgis_upgrade.sql script in all your existing databases will
          work. See the <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">soft upgrade</a>
          chapter for more information.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312560"></a>A.1.13.3. New functions</h4></div></div></div><p>scale() and transscale() companion methods to translate()</p><p>line_substring()</p><p>line_locate_point()</p><p>M(point)</p><p>LineMerge(geometry)</p><p>shift_longitude(geometry)</p><p>azimuth(geometry)</p><p>locate_along_measure(geometry, float8)</p><p>locate_between_measures(geometry, float8, float8)</p><p>SnapToGrid by point offset (up to 4d support)</p><p>BuildArea(any_geometry)</p><p>OGC BdPolyFromText(linestring_wkt, srid)</p><p>OGC BdMPolyFromText(linestring_wkt, srid)</p><p>RemovePoint(linestring, offset)</p><p>ReplacePoint(linestring, offset, point)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312615"></a>A.1.13.4. Bug fixes</h4></div></div></div><p>Fixed memory leak in polygonize()</p><p>Fixed bug in lwgeom_as_anytype cast functions</p><p>Fixed USE_GEOS, USE_PROJ and USE_STATS elements of
          postgis_version() output to always reflect library state.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312632"></a>A.1.13.5. Function semantic changes</h4></div></div></div><p>SnapToGrid doesn't discard higher dimensions</p><p>Changed Z() function to return NULL if requested dimension is
          not available</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312645"></a>A.1.13.6. Performance improvements</h4></div></div></div><p>Much faster transform() function, caching proj4 objects</p><p>Removed automatic call to fix_geometry_columns() in
          AddGeometryColumns() and update_geometry_stats()</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312659"></a>A.1.13.7. JDBC2 works</h4></div></div></div><p>Makefile improvements</p><p>JTS support improvements</p><p>Improved regression test system</p><p>Basic consistency check method for geometry collections</p><p>Support for (Hex)(E)wkb</p><p>Autoprobing DriverWrapper for HexWKB / EWKT switching</p><p>fix compile problems in ValueSetter for ancient jdk releases.</p><p>fix EWKT constructors to accept SRID=4711; representation</p><p>added preliminary read-only support for java2d geometries</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312696"></a>A.1.13.8. Other new things</h4></div></div></div><p>Full autoconf-based configuration, with PostgreSQL source
          dependency relief</p><p>GEOS C-API support (2.2.0 and higher)</p><p>Initial support for topology modelling</p><p>Debian and RPM specfiles</p><p>New lwpostgis_upgrade.sql script</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312720"></a>A.1.13.9. Other changes</h4></div></div></div><p>JTS support improvements</p><p>Stricter mapping between DBF and SQL integer and string
          attributes</p><p>Wider and cleaner regression test suite</p><p>old jdbc code removed from release</p><p>obsoleted direct use of postgis_proc_upgrade.pl</p><p>scripts version unified with release version</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312747"></a>A.1.14. Release 1.0.6</h3></div></div></div><p>Release date: 2005/12/06</p><p>Contains a few bug fixes and improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312759"></a>A.1.14.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312793"></a>A.1.14.2. Bug fixes</h4></div></div></div><p>Fixed palloc(0) call in collection deserializer (only gives
          problem with --enable-cassert)</p><p>Fixed bbox cache handling bugs</p><p>Fixed geom_accum(NULL, NULL) segfault</p><p>Fixed segfault in addPoint()</p><p>Fixed short-allocation in lwcollection_clone()</p><p>Fixed bug in segmentize()</p><p>Fixed bbox computation of SnapToGrid output</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312823"></a>A.1.14.3. Improvements</h4></div></div></div><p>Initial support for postgresql 8.2</p><p>Added missing SRID mismatch checks in GEOS ops</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312836"></a>A.1.15. Release 1.0.5</h3></div></div></div><p>Release date: 2005/11/25</p><p>Contains memory-alignment fixes in the library, a segfault fix
        in loader's handling of UTF8 attributes and a few improvements and
        cleanups.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Return code of shp2pgsql changed from previous releases to
          conform to unix standards (return 0 on success).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312857"></a>A.1.15.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 or later you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312891"></a>A.1.15.2. Library changes</h4></div></div></div><p>Fixed memory alignment problems</p><p>Fixed computation of null values fraction in analyzer</p><p>Fixed a small bug in the getPoint4d_p() low-level function</p><p>Speedup of serializer functions</p><p>Fixed a bug in force_3dm(), force_3dz() and force_4d()</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312914"></a>A.1.15.3. Loader changes</h4></div></div></div><p>Fixed return code of shp2pgsql</p><p>Fixed back-compatibility issue in loader (load of null
          shapefiles)</p><p>Fixed handling of trailing dots in dbf numerical attributes</p><p>Segfault fix in shp2pgsql (utf8 encoding)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312935"></a>A.1.15.4. Other changes</h4></div></div></div><p>Schema aware postgis_proc_upgrade.pl, support for pgsql 7.2+</p><p>New "Reporting Bugs" chapter in manual</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id312950"></a>A.1.16. Release 1.0.4</h3></div></div></div><p>Release date: 2005/09/09</p><p>Contains important bug fixes and a few improvements. In
        particular, it fixes a memory leak preventing successful build of GiST
        indexes for large spatial tables.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312963"></a>A.1.16.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.3 you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>If you are upgrading from a release <span class="emphasis"><em>between 1.0.0RC6
          and 1.0.2</em></span> (inclusive) and really want a live upgrade read
          the <a class="link" href="#rel_1.0.3_upgrading" title="A.1.17. Release 1.0.3">upgrade section</a> of
          the 1.0.3 release notes chapter.</p><p>Upgrade from any release prior to 1.0.0RC6 requires an <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id312996"></a>A.1.16.2. Bug fixes</h4></div></div></div><p>Memory leak plugged in GiST indexing</p><p>Segfault fix in transform() handling of proj4 errors</p><p>Fixed some proj4 texts in spatial_ref_sys (missing +proj)</p><p>Loader: fixed string functions usage, reworked NULL objects
          check, fixed segfault on MULTILINESTRING input.</p><p>Fixed bug in MakeLine dimension handling</p><p>Fixed bug in translate() corrupting output bounding box</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313024"></a>A.1.16.3. Improvements</h4></div></div></div><p>Documentation improvements</p><p>More robust selectivity estimator</p><p>Minor speedup in distance()</p><p>Minor cleanups</p><p>GiST indexing cleanup</p><p>Looser syntax acceptance in box3d parser</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="rel_1.0.3_upgrading"></a>A.1.17. Release 1.0.3</h3></div></div></div><p>Release date: 2005/08/08</p><p>Contains some bug fixes - <span class="emphasis"><em>including a severe one
        affecting correctness of stored geometries</em></span> - and a few
        improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313068"></a>A.1.17.1. Upgrading</h4></div></div></div><p>Due to a bug in a bounding box computation routine, the
          upgrade procedure requires special attention, as bounding boxes
          cached in the database could be incorrect.</p><p>An <a class="link" href="#hard_upgrade" title="2.2.2.2. Hard upgrade">hard upgrade</a> procedure
          (dump/reload) will force recomputation of all bounding boxes (not
          included in dumps). This is <span class="emphasis"><em>required</em></span> if
          upgrading from releases prior to 1.0.0RC6.</p><p>If you are upgrading from versions 1.0.0RC6 or up, this
          release includes a perl script (utils/rebuild_bbox_caches.pl) to
          force recomputation of geometries' bounding boxes and invoke all
          operations required to propagate eventual changes in them (geometry
          statistics update, reindexing). Invoke the script after a make
          install (run with no args for syntax help). Optionally run
          utils/postgis_proc_upgrade.pl to refresh postgis procedures and
          functions signatures (see <a class="link" href="#soft_upgrade" title="2.2.2.1. Soft upgrade">Soft upgrade</a>).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313106"></a>A.1.17.2. Bug fixes</h4></div></div></div><p>Severe bugfix in lwgeom's 2d bounding box computation</p><p>Bugfix in WKT (-w) POINT handling in loader</p><p>Bugfix in dumper on 64bit machines</p><p>Bugfix in dumper handling of user-defined queries</p><p>Bugfix in create_undef.pl script</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313128"></a>A.1.17.3. Improvements</h4></div></div></div><p>Small performance improvement in canonical input function</p><p>Minor cleanups in loader</p><p>Support for multibyte field names in loader</p><p>Improvement in the postgis_restore.pl script</p><p>New rebuild_bbox_caches.pl util script</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313152"></a>A.1.18. Release 1.0.2</h3></div></div></div><p>Release date: 2005/07/04</p><p>Contains a few bug fixes and improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313164"></a>A.1.18.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.0RC6 or up you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>Upgrading from older releases requires a dump/reload. See the
          <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313187"></a>A.1.18.2. Bug fixes</h4></div></div></div><p>Fault tolerant btree ops</p><p>Memory leak plugged in pg_error</p><p>Rtree index fix</p><p>Cleaner build scripts (avoided mix of CFLAGS and CXXFLAGS)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313207"></a>A.1.18.3. Improvements</h4></div></div></div><p>New index creation capabilities in loader (-I switch)</p><p>Initial support for postgresql 8.1dev</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313220"></a>A.1.19. Release 1.0.1</h3></div></div></div><p>Release date: 2005/05/24</p><p>Contains a few bug fixes and some improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313232"></a>A.1.19.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.0RC6 or up you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>Upgrading from older releases requires a dump/reload. See the
          <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313255"></a>A.1.19.2. Library changes</h4></div></div></div><p>BUGFIX in 3d computation of length_spheroid()</p><p>BUGFIX in join selectivity estimator</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313268"></a>A.1.19.3. Other changes/additions</h4></div></div></div><p>BUGFIX in shp2pgsql escape functions</p><p>better support for concurrent postgis in multiple schemas</p><p>documentation fixes</p><p>jdbc2: compile with "-target 1.2 -source 1.2" by
          default</p><p>NEW -k switch for pgsql2shp</p><p>NEW support for custom createdb options in postgis_restore.pl</p><p>BUGFIX in pgsql2shp attribute names unicity enforcement</p><p>BUGFIX in Paris projections definitions</p><p>postgis_restore.pl cleanups</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313306"></a>A.1.20. Release 1.0.0</h3></div></div></div><p>Release date: 2005/04/19</p><p>Final 1.0.0 release. Contains a few bug fixes, some improvements
        in the loader (most notably support for older postgis versions), and
        more docs.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313320"></a>A.1.20.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.0RC6 you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>Upgrading from any other precedent release requires a
          dump/reload. See the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a>
          chapter for more informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313342"></a>A.1.20.2. Library changes</h4></div></div></div><p>BUGFIX in transform() releasing random memory address</p><p>BUGFIX in force_3dm() allocating less memory then required</p><p>BUGFIX in join selectivity estimator (defaults, leaks,
          tuplecount, sd)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313360"></a>A.1.20.3. Other changes/additions</h4></div></div></div><p>BUGFIX in shp2pgsql escape of values starting with tab or
          single-quote</p><p>NEW manual pages for loader/dumper</p><p>NEW shp2pgsql support for old (HWGEOM) postgis versions</p><p>NEW -p (prepare) flag for shp2pgsql</p><p>NEW manual chapter about OGC compliancy enforcement</p><p>NEW autoconf support for JTS lib</p><p>BUGFIX in estimator testers (support for LWGEOM and schema
          parsing)</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313391"></a>A.1.21. Release 1.0.0RC6</h3></div></div></div><p>Release date: 2005/03/30</p><p>Sixth release candidate for 1.0.0. Contains a few bug fixes and
        cleanups.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313404"></a>A.1.21.1. Upgrading</h4></div></div></div><p>You need a dump/reload to upgrade from precedent releases. See
          the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313419"></a>A.1.21.2. Library changes</h4></div></div></div><p>BUGFIX in multi()</p><p>early return [when noop] from multi()</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313432"></a>A.1.21.3. Scripts changes</h4></div></div></div><p>dropped {x,y}{min,max}(box2d) functions</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313442"></a>A.1.21.4. Other changes</h4></div></div></div><p>BUGFIX in postgis_restore.pl scrip</p><p>BUGFIX in dumper's 64bit support</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313456"></a>A.1.22. Release 1.0.0RC5</h3></div></div></div><p>Release date: 2005/03/25</p><p>Fifth release candidate for 1.0.0. Contains a few bug fixes and
        a improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313468"></a>A.1.22.1. Upgrading</h4></div></div></div><p>If you are upgrading from release 1.0.0RC4 you
          <span class="emphasis"><em>DO NOT</em></span> need a dump/reload.</p><p>Upgrading from any other precedent release requires a
          dump/reload. See the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a>
          chapter for more informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313491"></a>A.1.22.2. Library changes</h4></div></div></div><p>BUGFIX (segfaulting) in box3d computation (yes, another!).</p><p>BUGFIX (segfaulting) in estimated_extent().</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313504"></a>A.1.22.3. Other changes</h4></div></div></div><p>Small build scripts and utilities refinements.</p><p>Additional performance tips documented.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313518"></a>A.1.23. Release 1.0.0RC4</h3></div></div></div><p>Release date: 2005/03/18</p><p>Fourth release candidate for 1.0.0. Contains bug fixes and a few
        improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313531"></a>A.1.23.1. Upgrading</h4></div></div></div><p>You need a dump/reload to upgrade from precedent releases. See
          the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313546"></a>A.1.23.2. Library changes</h4></div></div></div><p>BUGFIX (segfaulting) in geom_accum().</p><p>BUGFIX in 64bit architectures support.</p><p>BUGFIX in box3d computation function with collections.</p><p>NEW subselects support in selectivity estimator.</p><p>Early return from force_collection.</p><p>Consistency check fix in SnapToGrid().</p><p>Box2d output changed back to 15 significant digits.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313575"></a>A.1.23.3. Scripts changes</h4></div></div></div><p>NEW distance_sphere() function.</p><p>Changed get_proj4_from_srid implementation to use PL/PGSQL
          instead of SQL.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313589"></a>A.1.23.4. Other changes</h4></div></div></div><p>BUGFIX in loader and dumper handling of MultiLine shapes</p><p>BUGFIX in loader, skipping all but first hole of polygons.</p><p>jdbc2: code cleanups, Makefile improvements</p><p>FLEX and YACC variables set *after* pgsql Makefile.global is
          included and only if the pgsql *stripped* version evaluates to the
          empty string</p><p>Added already generated parser in release</p><p>Build scripts refinements</p><p>improved version handling, central Version.config</p><p>improvements in postgis_restore.pl</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313625"></a>A.1.24. Release 1.0.0RC3</h3></div></div></div><p>Release date: 2005/02/24</p><p>Third release candidate for 1.0.0. Contains many bug fixes and
        improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313637"></a>A.1.24.1. Upgrading</h4></div></div></div><p>You need a dump/reload to upgrade from precedent releases. See
          the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313653"></a>A.1.24.2. Library changes</h4></div></div></div><p>BUGFIX in transform(): missing SRID, better error handling.</p><p>BUGFIX in memory alignment handling</p><p>BUGFIX in force_collection() causing mapserver connector
          failures on simple (single) geometry types.</p><p>BUGFIX in GeometryFromText() missing to add a bbox cache.</p><p>reduced precision of box2d output.</p><p>prefixed DEBUG macros with PGIS_ to avoid clash with pgsql one</p><p>plugged a leak in GEOS2POSTGIS converter</p><p>Reduced memory usage by early releasing query-context palloced
          one.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313689"></a>A.1.24.3. Scripts changes</h4></div></div></div><p>BUGFIX in 72 index bindings.</p><p>BUGFIX in probe_geometry_columns() to work with PG72 and
          support multiple geometry columns in a single table</p><p>NEW bool::text cast</p><p>Some functions made IMMUTABLE from STABLE, for performance
          improvement.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313710"></a>A.1.24.4. JDBC changes</h4></div></div></div><p>jdbc2: small patches, box2d/3d tests, revised docs and
          license.</p><p>jdbc2: bug fix and testcase in for pgjdbc 8.0 type
          autoregistration</p><p>jdbc2: Removed use of jdk1.4 only features to enable build
          with older jdk releases.</p><p>jdbc2: Added support for building against pg72jdbc2.jar</p><p>jdbc2: updated and cleaned makefile</p><p>jdbc2: added BETA support for jts geometry classes</p><p>jdbc2: Skip known-to-fail tests against older PostGIS servers.</p><p>jdbc2: Fixed handling of measured geometries in EWKT.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313745"></a>A.1.24.5. Other changes</h4></div></div></div><p>new performance tips chapter in manual</p><p>documentation updates: pgsql72 requirement, lwpostgis.sql</p><p>few changes in autoconf</p><p>BUILDDATE extraction made more portable</p><p>fixed spatial_ref_sys.sql to avoid vacuuming the whole
          database.</p><p>spatial_ref_sys: changed Paris entries to match the ones
          distributed with 0.x.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313774"></a>A.1.25. Release 1.0.0RC2</h3></div></div></div><p>Release date: 2005/01/26</p><p>Second release candidate for 1.0.0 containing bug fixes and a
        few improvements.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313786"></a>A.1.25.1. Upgrading</h4></div></div></div><p>You need a dump/reload to upgrade from precedent releases. See
          the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313802"></a>A.1.25.2. Library changes</h4></div></div></div><p>BUGFIX in pointarray box3d computation</p><p>BUGFIX in distance_spheroid definition</p><p>BUGFIX in transform() missing to update bbox cache</p><p>NEW jdbc driver (jdbc2)</p><p>GEOMETRYCOLLECTION(EMPTY) syntax support for backward
          compatibility</p><p>Faster binary outputs</p><p>Stricter OGC WKB/WKT constructors</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313832"></a>A.1.25.3. Scripts changes</h4></div></div></div><p>More correct STABLE, IMMUTABLE, STRICT uses in lwpostgis.sql</p><p>stricter OGC WKB/WKT constructors</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313845"></a>A.1.25.4. Other changes</h4></div></div></div><p>Faster and more robust loader (both i18n and not)</p><p>Initial autoconf script</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id313859"></a>A.1.26. Release 1.0.0RC1</h3></div></div></div><p>Release date: 2005/01/13</p><p>This is the first candidate of a major postgis release, with
        internal storage of postgis types redesigned to be smaller and faster
        on indexed queries.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313872"></a>A.1.26.1. Upgrading</h4></div></div></div><p>You need a dump/reload to upgrade from precedent releases. See
          the <a class="link" href="#upgrading" title="2.2.2. Upgrading">upgrading</a> chapter for more
          informations.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id313888"></a>A.1.26.2. Changes</h4></div></div></div><p>Faster canonical input parsing.</p><p>Lossless canonical output.</p><p>EWKB Canonical binary IO with PG&gt;73.</p><p>Support for up to 4d coordinates, providing lossless
          shapefile-&gt;postgis-&gt;shapefile conversion.</p><p>New function: UpdateGeometrySRID(), AsGML(), SnapToGrid(),
          ForceRHR(), estimated_extent(), accum().</p><p>Vertical positioning indexed operators.</p><p>JOIN selectivity function.</p><p>More geometry constructors / editors.</p><p>PostGIS extension API.</p><p>UTF8 support in loader.</p></div></div></div></div></div></body></html>
